<!DOCTYPE html>
<html>
<head>
    

    

    



    <meta charset="utf-8">
    
    
    
    
    <title>Java虚拟机 | 我的技术笔记</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    
    <meta name="theme-color" content="#3F51B5">
    
    
    <meta name="keywords" content="Java,JVM">
    <meta name="description" content="1.   运行时数据区域1.1.    程序计数器记录正在执行的虚拟机字节码指令的地址（如果正在执行的是本地方法则为空）。字节码解释器工作时通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等功能都需要依赖这个计数器来完成。 另外，为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各线程之间计数器互不影响，独立存储，我们称这类内存">
<meta property="og:type" content="article">
<meta property="og:title" content="Java虚拟机">
<meta property="og:url" content="https://xdmqp.github.io/2021/03/14/Java%E8%99%9A%E6%8B%9F%E6%9C%BA/index.html">
<meta property="og:site_name" content="我的技术笔记">
<meta property="og:description" content="1.   运行时数据区域1.1.    程序计数器记录正在执行的虚拟机字节码指令的地址（如果正在执行的是本地方法则为空）。字节码解释器工作时通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等功能都需要依赖这个计数器来完成。 另外，为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各线程之间计数器互不影响，独立存储，我们称这类内存">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://raw.githubusercontent.com/xdmqp/myPic/main/img/JVM%E5%A0%86%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84-JDK7.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xdmqp/myPic/main/img/JVM%E5%A0%86%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84-jdk8.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20210425134508117.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xdmqp/myPic/main/img/Java%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E7%9A%84%E8%BF%87%E7%A8%8B.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xdmqp/myPic/main/img/%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%96%B9%E5%BC%8F.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xdmqp/myPic/main/img/%E5%AF%B9%E8%B1%A1%E7%9A%84%E8%AE%BF%E9%97%AE%E5%AE%9A%E4%BD%8D-%E4%BD%BF%E7%94%A8%E5%8F%A5%E6%9F%84.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xdmqp/myPic/main/img/%E5%AF%B9%E8%B1%A1%E7%9A%84%E8%AE%BF%E9%97%AE%E5%AE%9A%E4%BD%8D-%E7%9B%B4%E6%8E%A5%E6%8C%87%E9%92%88.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xdmqp/myPic/main/img/clip_image002.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xdmqp/myPic/main/img/clip_image004.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xdmqp/myPic/main/img/clip_image006.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xdmqp/myPic/main/img/clip_image008.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xdmqp/myPic/main/img/335fe19c-4a76-45ab-9320-88c90d6a0d7e.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xdmqp/myPic/main/img/0dd2d40a-5b2b-4d45-b176-e75a4cd4bdbf.png">
<meta property="article:published_time" content="2021-03-13T16:00:00.000Z">
<meta property="article:modified_time" content="2021-07-07T02:56:49.241Z">
<meta property="article:author" content="登高必自">
<meta property="article:tag" content="Java">
<meta property="article:tag" content="JVM">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://raw.githubusercontent.com/xdmqp/myPic/main/img/JVM%E5%A0%86%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84-JDK7.png">
    
        <link rel="alternate" type="application/atom+xml" title="我的技术笔记" href="/atom.xml">
    
    <link rel="shortcut icon" href="/favicon.ico">
    <link rel="stylesheet" href="//unpkg.com/hexo-theme-material-indigo@latest/css/style.css">
    <script>window.lazyScripts=[]</script>

    <!-- custom head -->
    

<meta name="generator" content="Hexo 4.2.1"></head>

<body>
    <div id="loading" class="active"></div>

    <aside id="menu" class="hide" >
  <div class="inner flex-row-vertical">
    <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menu-off">
        <i class="icon icon-lg icon-close"></i>
    </a>
    <div class="brand-wrap" style="background-image:url(/img/brand.jpg)">
      <div class="brand">
        <a href="/" class="avatar waves-effect waves-circle waves-light">
          <img src="/img/avatar.jpg">
        </a>
        <hgroup class="introduce">
          <h5 class="nickname">登高必自</h5>
          <a href="mailto:1254723220@qq.com" title="1254723220@qq.com" class="mail">1254723220@qq.com</a>
        </hgroup>
      </div>
    </div>
    <div class="scroll-wrap flex-col">
      <ul class="nav">
        
            <li class="waves-block waves-effect">
              <a href="/"  >
                <i class="icon icon-lg icon-home"></i>
                主页
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/archives"  >
                <i class="icon icon-lg icon-archives"></i>
                归档
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/tags"  >
                <i class="icon icon-lg icon-tags"></i>
                标签
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/categories"  >
                <i class="icon icon-lg icon-th-list"></i>
                分类
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="https://github.com/xdmqp" target="_blank" >
                <i class="icon icon-lg icon-github"></i>
                Github
              </a>
            </li>
        
      </ul>
    </div>
  </div>
</aside>

    <main id="main">
        <header class="top-header" id="header">
    <div class="flex-row">
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light on" id="menu-toggle">
          <i class="icon icon-lg icon-navicon"></i>
        </a>
        <div class="flex-col header-title ellipsis">Java虚拟机</div>
        
        <div class="search-wrap" id="search-wrap">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="back">
                <i class="icon icon-lg icon-chevron-left"></i>
            </a>
            <input type="text" id="key" class="search-input" autocomplete="off" placeholder="输入感兴趣的关键字">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="search">
                <i class="icon icon-lg icon-search"></i>
            </a>
        </div>
        
        
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menuShare">
            <i class="icon icon-lg icon-share-alt"></i>
        </a>
        
    </div>
</header>
<header class="content-header post-header">

    <div class="container fade-scale">
        <h1 class="title">Java虚拟机</h1>
        <h5 class="subtitle">
            
                <time datetime="2021-03-13T16:00:00.000Z" itemprop="datePublished" class="page-time">
  2021-03-14
</time>


	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/Java/">Java</a></li></ul>

            
        </h5>
    </div>

    


</header>


<div class="container body-wrap">
    
    <aside class="post-widget">
        <nav class="post-toc-wrap post-toc-shrink" id="post-toc">
            <h4>TOC</h4>
            <ol class="post-toc"><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#1-运行时数据区域"><span class="post-toc-number">1.</span> <span class="post-toc-text">1.   运行时数据区域</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#1-1-程序计数器"><span class="post-toc-number">1.1.</span> <span class="post-toc-text">1.1.    程序计数器</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#1-2-Java虚拟机栈"><span class="post-toc-number">1.2.</span> <span class="post-toc-text">1.2.    Java虚拟机栈</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#1-3-本地方法栈"><span class="post-toc-number">1.3.</span> <span class="post-toc-text">1.3.    本地方法栈</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#1-4-堆"><span class="post-toc-number">1.4.</span> <span class="post-toc-text">1.4.    堆</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#1-5-方法区"><span class="post-toc-number">1.5.</span> <span class="post-toc-text">1.5.    方法区</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#1-6-运行时常量池"><span class="post-toc-number">1.6.</span> <span class="post-toc-text">1.6.    运行时常量池</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#1-7-直接内存"><span class="post-toc-number">1.7.</span> <span class="post-toc-text">1.7.    直接内存</span></a></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#2-HotSpot虚拟机对象"><span class="post-toc-number">2.</span> <span class="post-toc-text">2.   HotSpot虚拟机对象</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#2-1-对象的创建过程"><span class="post-toc-number">2.1.</span> <span class="post-toc-text">2.1. 对象的创建过程</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#2-1-1-类加载检查"><span class="post-toc-number">2.1.1.</span> <span class="post-toc-text">2.1.1. 类加载检查</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#2-1-2-分配内存"><span class="post-toc-number">2.1.2.</span> <span class="post-toc-text">2.1.2. 分配内存</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#2-1-3-初始化零值"><span class="post-toc-number">2.1.3.</span> <span class="post-toc-text">2.1.3. 初始化零值</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#2-1-4-设置对象头"><span class="post-toc-number">2.1.4.</span> <span class="post-toc-text">2.1.4. 设置对象头</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#2-1-5-执行init方法"><span class="post-toc-number">2.1.5.</span> <span class="post-toc-text">2.1.5. 执行init方法</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#2-2-对象内存布局"><span class="post-toc-number">2.2.</span> <span class="post-toc-text">2.2. 对象内存布局</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#2-3-对象的访问定位方式"><span class="post-toc-number">2.3.</span> <span class="post-toc-text">2.3.  对象的访问定位方式</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#2-3-1-使用句柄"><span class="post-toc-number">2.3.1.</span> <span class="post-toc-text">2.3.1.  使用句柄</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#2-3-2-直接指针"><span class="post-toc-number">2.3.2.</span> <span class="post-toc-text">2.3.2.  直接指针</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#2-3-3-对比"><span class="post-toc-number">2.3.3.</span> <span class="post-toc-text">2.3.3.  对比</span></a></li></ol></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#3-垃圾收集"><span class="post-toc-number">3.</span> <span class="post-toc-text">3.   垃圾收集</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#3-1-判断一个对象是否可被回收"><span class="post-toc-number">3.1.</span> <span class="post-toc-text">3.1.    判断一个对象是否可被回收</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#3-1-1-引用计数算法"><span class="post-toc-number">3.1.1.</span> <span class="post-toc-text">3.1.1.  引用计数算法</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#3-1-2-可达性分析算法"><span class="post-toc-number">3.1.2.</span> <span class="post-toc-text">3.1.2.  可达性分析算法</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#3-1-3-方法区回收"><span class="post-toc-number">3.1.3.</span> <span class="post-toc-text">3.1.3.  方法区回收</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#3-1-4-finalize"><span class="post-toc-number">3.1.4.</span> <span class="post-toc-text">3.1.4.  finalize()</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#3-2-引用类型"><span class="post-toc-number">3.2.</span> <span class="post-toc-text">3.2.    引用类型</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#3-2-1-强引用"><span class="post-toc-number">3.2.1.</span> <span class="post-toc-text">3.2.1.  强引用</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#3-2-2-软引用"><span class="post-toc-number">3.2.2.</span> <span class="post-toc-text">3.2.2.  软引用</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#3-2-3-弱引用"><span class="post-toc-number">3.2.3.</span> <span class="post-toc-text">3.2.3.  弱引用</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#3-2-4-虚引用"><span class="post-toc-number">3.2.4.</span> <span class="post-toc-text">3.2.4.  虚引用</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#3-3-垃圾收集算法"><span class="post-toc-number">3.3.</span> <span class="post-toc-text">3.3.    垃圾收集算法</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#3-3-1-标记-清除"><span class="post-toc-number">3.3.1.</span> <span class="post-toc-text">3.3.1.  标记-清除</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#3-3-2-标记-整理"><span class="post-toc-number">3.3.2.</span> <span class="post-toc-text">3.3.2.  标记-整理</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#3-3-3-标记-复制"><span class="post-toc-number">3.3.3.</span> <span class="post-toc-text">3.3.3.  标记-复制</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#3-3-4-分代收集"><span class="post-toc-number">3.3.4.</span> <span class="post-toc-text">3.3.4.  分代收集</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#3-4-垃圾收集器"><span class="post-toc-number">3.4.</span> <span class="post-toc-text">3.4.    垃圾收集器</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#3-4-1-1-Serial收集器"><span class="post-toc-number">3.4.1.</span> <span class="post-toc-text">3.4.1.  1.Serial收集器</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#3-4-2-2-ParNew收集器"><span class="post-toc-number">3.4.2.</span> <span class="post-toc-text">3.4.2.  2.ParNew收集器</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#3-4-3-3-Parallel-Scavenge-收集器"><span class="post-toc-number">3.4.3.</span> <span class="post-toc-text">3.4.3.  3.Parallel Scavenge 收集器</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#3-4-4-4-Serial-Old收集器"><span class="post-toc-number">3.4.4.</span> <span class="post-toc-text">3.4.4.  4.Serial Old收集器</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#3-4-5-5-Parallel-Old收集器"><span class="post-toc-number">3.4.5.</span> <span class="post-toc-text">3.4.5.  5.Parallel Old收集器</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#3-4-6-6-CMS收集器"><span class="post-toc-number">3.4.6.</span> <span class="post-toc-text">3.4.6.  6.CMS收集器</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#3-4-7-7-G1收集器"><span class="post-toc-number">3.4.7.</span> <span class="post-toc-text">3.4.7.  7.G1收集器</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#3-4-8-8-ZGC收集器"><span class="post-toc-number">3.4.8.</span> <span class="post-toc-text">3.4.8.  8.ZGC收集器</span></a></li></ol></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#4-内存分配与回收"><span class="post-toc-number">4.</span> <span class="post-toc-text">4.   内存分配与回收</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#4-1-Minor-GC和Full-GC"><span class="post-toc-number">4.1.</span> <span class="post-toc-text">4.1.    Minor GC和Full GC</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#4-2-内存分配策略"><span class="post-toc-number">4.2.</span> <span class="post-toc-text">4.2.    内存分配策略</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#4-2-1-1-对象优先在Eden分配"><span class="post-toc-number">4.2.1.</span> <span class="post-toc-text">4.2.1.  1.对象优先在Eden分配</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#4-2-2-2-大对象直接进入老年代"><span class="post-toc-number">4.2.2.</span> <span class="post-toc-text">4.2.2.  2.大对象直接进入老年代</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#4-2-3-3-长期存活的对象进入老年代"><span class="post-toc-number">4.2.3.</span> <span class="post-toc-text">4.2.3.  3.长期存活的对象进入老年代</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#4-2-4-4-动态对象年龄判定"><span class="post-toc-number">4.2.4.</span> <span class="post-toc-text">4.2.4.  4.动态对象年龄判定</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#4-2-5-5-空间分配担保"><span class="post-toc-number">4.2.5.</span> <span class="post-toc-text">4.2.5.  5.空间分配担保</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#4-3-Full-GC的触发条件"><span class="post-toc-number">4.3.</span> <span class="post-toc-text">4.3.    Full GC的触发条件</span></a></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#5-类加载机制"><span class="post-toc-number">5.</span> <span class="post-toc-text">5.   类加载机制</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#5-1-类的生命周期"><span class="post-toc-number">5.1.</span> <span class="post-toc-text">5.1.    类的生命周期</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#5-2-类加载过程"><span class="post-toc-number">5.2.</span> <span class="post-toc-text">5.2.    类加载过程</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#5-2-1-加载"><span class="post-toc-number">5.2.1.</span> <span class="post-toc-text">5.2.1.  加载</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#5-2-2-验证"><span class="post-toc-number">5.2.2.</span> <span class="post-toc-text">5.2.2.  验证</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#5-2-3-准备"><span class="post-toc-number">5.2.3.</span> <span class="post-toc-text">5.2.3.  准备</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#5-2-4-解析"><span class="post-toc-number">5.2.4.</span> <span class="post-toc-text">5.2.4.  解析</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#5-2-5-初始化"><span class="post-toc-number">5.2.5.</span> <span class="post-toc-text">5.2.5.  初始化</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#5-3-类初始化时机"><span class="post-toc-number">5.3.</span> <span class="post-toc-text">5.3.    类初始化时机</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#5-3-1-主动引用"><span class="post-toc-number">5.3.1.</span> <span class="post-toc-text">5.3.1.  主动引用</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#5-3-2-被动引用"><span class="post-toc-number">5.3.2.</span> <span class="post-toc-text">5.3.2.  被动引用</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#5-4-类与类加载器"><span class="post-toc-number">5.4.</span> <span class="post-toc-text">5.4.    类与类加载器</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#5-5-类加载器分类"><span class="post-toc-number">5.5.</span> <span class="post-toc-text">5.5.    类加载器分类</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#5-6-双亲委派模型"><span class="post-toc-number">5.6.</span> <span class="post-toc-text">5.6.    双亲委派模型</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#5-6-1-工作过程"><span class="post-toc-number">5.6.1.</span> <span class="post-toc-text">5.6.1.  工作过程</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#5-6-2-好处"><span class="post-toc-number">5.6.2.</span> <span class="post-toc-text">5.6.2.  好处</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#5-6-3-实现"><span class="post-toc-number">5.6.3.</span> <span class="post-toc-text">5.6.3.  实现</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#5-7-自定义类加载器实现"><span class="post-toc-number">5.7.</span> <span class="post-toc-text">5.7.    自定义类加载器实现</span></a></li></ol></li></ol>
        </nav>
    </aside>


<article id="post-Java虚拟机"
  class="post-article article-type-post fade" itemprop="blogPost">

    <div class="post-card">
        <h1 class="post-card-title">Java虚拟机</h1>
        <div class="post-meta">
            <time class="post-time" title="2021-03-14 00:00:00" datetime="2021-03-13T16:00:00.000Z"  itemprop="datePublished">2021-03-14</time>

            
	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/Java/">Java</a></li></ul>



            
<span id="busuanzi_container_page_pv" title="文章总阅读量" style='display:none'>
    <i class="icon icon-eye icon-pr"></i><span id="busuanzi_value_page_pv"></span>
</span>


        </div>
        <div class="post-content" id="post-content" itemprop="postContent">
            <h1 id="1-运行时数据区域"><a href="#1-运行时数据区域" class="headerlink" title="1.   运行时数据区域"></a>1.   运行时数据区域</h1><h2 id="1-1-程序计数器"><a href="#1-1-程序计数器" class="headerlink" title="1.1.    程序计数器"></a>1.1.    程序计数器</h2><p>记录<strong>正在执行的虚拟机字节码指令的地址</strong>（如果正在执行的是本地方法则为空）。字节码解释器工作时<strong>通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等功能都需要依赖这个计数器来完成。</strong><br> 另外，为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各线程之间计数器互不影响，独立存储，我们称这类内存区域为“线程私有”的内存。<br> 程序计数器的两个作用：<br> 字节码解释器通过改变程序计数器来依次读取指令，从而<strong>实现代码的流程控制</strong>，如：顺序执行、选择、循环、异常处理。<br> 在多线程的情况下，<strong>程序计数器用于记录当前线程执行的位置</strong>，从而当线程被切换回来的时候能够知道该线程上次运行到哪儿了。</p>
<h2 id="1-2-Java虚拟机栈"><a href="#1-2-Java虚拟机栈" class="headerlink" title="1.2.    Java虚拟机栈"></a>1.2.    Java虚拟机栈</h2><p>每个 Java 方法在执行的同时会创建一个栈帧用于存储<strong>局部变量表（8种基本类型、对象的引用地址）、操作数栈、动态链接、方法出口</strong>等信息。从方法调用直至执行完成的过程，对应着一个栈帧在 Java 虚拟机栈中入栈和出栈的过程。<br> 可以通过 -Xss 这个虚拟机参数来指定每个线程的 Java 虚拟机栈内存大小，在 JDK 1.4 中默认为 256K，而在 JDK 1.5+ 默认为 1M<br> 操作Java虚拟机栈有可能会抛出以下异常：<br> <strong>当线程请求的栈深度超过最大值</strong>，会抛出 StackOverflowError 异常；<br> <strong>栈进行动态扩展时如果无法申请到足够内存</strong>，会抛出 OutOfMemoryError 异常。</p>
<h2 id="1-3-本地方法栈"><a href="#1-3-本地方法栈" class="headerlink" title="1.3.    本地方法栈"></a>1.3.    本地方法栈</h2><p>本地方法栈与 Java 虚拟机栈类似，<strong>它们之间的区别只不过是本地方法栈为本地方法服务</strong>。在 HotSpot 虚拟机中和 Java 虚拟机栈合二为一。<br> 本地方法被执行的时候，在本地方法栈也会创建一个栈帧，用于存放该本地方法的局部变量表、操作数栈、动态链接、出口信息。<br> 方法执行完毕后相应的栈帧也会出栈并释放内存空间，也会出现 StackOverFlowError 和 OutOfMemoryError 两种错误。</p>
<h2 id="1-4-堆"><a href="#1-4-堆" class="headerlink" title="1.4.    堆"></a>1.4.    堆</h2><p>用于<strong>存放对象实例，所有对象都在这里分配内存</strong>，是垃圾收集的主要区域（”GC 堆”）。</p>
<p>现代的垃圾收集器基本都是采用分代收集算法，其主要的思想是针对不同类型的对象采取不同的垃圾回收算法。可以将堆分成两块：新生代和老年代。</p>
<p> 在JDK7及以前，堆内存被分为三部分：新生代、老生代、永久代。</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://raw.githubusercontent.com/xdmqp/myPic/main/img/JVM%E5%A0%86%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84-JDK7.png" alt="JVM堆内存结构-JDK7" title="">
                </div>
                <div class="image-caption">JVM堆内存结构-JDK7</div>
            </figure>

<p>JDK8版本之后方法区被彻底移除，由元空间代替，元空间使用的是直接内存。</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://raw.githubusercontent.com/xdmqp/myPic/main/img/JVM%E5%A0%86%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84-jdk8.png" alt="JVM堆内存结构-JDK8" title="">
                </div>
                <div class="image-caption">JVM堆内存结构-JDK8</div>
            </figure>

<p><strong>图中的 Eden 区、两个 Survivor 区都属于新生代，中间一层属于老年代。</strong></p>
<p>大多数对象首先在Eden区进行分配，在进行一次垃圾回收后，如果对象仍然存活，则进入s0或者s1，并且对象的年龄还会加1，Eden区刚进入Survivor区后的初始年龄为1），当年龄增加到一定程度时，就会晋升到老年代中，默认为15岁。对象晋升到老年代的阈值可以通过<code>-XX:MaxTenuringThreshold</code> 来设置。</p>
<p>另外，<strong>Hotspot在遍历所有对象时，按照年龄从小到大对其所占用的大小进行累积，当累积的某个年龄大小超过了 survivor 区的一半时，取这个年龄和 MaxTenuringThreshold 中更小的一个值，作为新的晋升年龄阈值。</strong></p>
<ul>
<li>堆不需要连续内存，并且可以动态增加其内存，增加失败会抛出 OutOfMemoryError 异常。 可以通过 -Xms 和 -Xmx 这两个虚拟机参数来指定一个程序的堆内存大小，第一个参数设置初始值，第二个参数设置最大值。</li>
<li>当 JVM 花太多时间执行垃圾回收并且只能回收很少的堆空间时，会发生OutOfMemoryError错误。</li>
</ul>
<h2 id="1-5-方法区"><a href="#1-5-方法区" class="headerlink" title="1.5.    方法区"></a>1.5.    方法区</h2><p>用于存放<strong>已被加载的类信息、常量、静态变量、即时编译器编译后的代码</strong>等数据<br> 和堆一样不需要连续的内存，并且可以动态扩展，动态扩展失败一样会抛出 OutOfMemoryError 异常。<br> 对这块区域进行垃圾回收的主要目标是对常量池的回收和对类的卸载，但是一般比较难实现。</p>
<p> <strong>方法区是一个 JVM 规范，永久代与元空间都是其一种实现方式。</strong></p>
<p> HotSpot 虚拟机把它当成永久代来进行垃圾回收。但很难确定永久代的大小，因为它受到很多因素影响，并且每次 Full GC 之后永久代的大小都会改变，所以经常会抛出 OutOfMemoryError 异常。为了更容易管理方法区，从 JDK 1.8 开始，移除永久代，并把方法区移至元空间，它位于本地内存中，而不是虚拟机内存中。</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://img-blog.csdnimg.cn/20210425134508117.png" alt="img" title="">
                </div>
                <div class="image-caption">img</div>
            </figure>

<p>整个永久代有一个 JVM 本身设置的固定大小上限，无法进行调整，而元空间使用的是直接内存，受本机可用内存的限制，虽然元空间仍旧可能溢出，但是比原来出现的几率会更小。</p>
<p>可以使用 <code>-XX：MaxMetaspaceSize</code> 标志设置最大元空间大小，默认值为 unlimited，这意味着它只受系统内存的限制。<code>-XX：MetaspaceSize</code> 调整标志定义元空间的初始大小如果未指定此标志，则 Metaspace 将根据运行时的应用程序需求动态地重新调整大小。</p>
<h2 id="1-6-运行时常量池"><a href="#1-6-运行时常量池" class="headerlink" title="1.6.    运行时常量池"></a>1.6.    运行时常量池</h2><p>方法区的一部分。<br> Class 文件中的常量池（编译器生成的字面量和符号引用）会在类加载后被放入这个区域。<strong>字面量相当于Java语言层面常量的概念，如文本字符串，声明为final的常量值等，符号引用则属于编译原理方面的概念，包括了如下三种类型的常量：</strong></p>
<ol>
<li><p>类和接口的全限定名</p>
</li>
<li><p>字段名称和描述符</p>
</li>
<li><p>方法名称和描述符</p>
<p>除了在编译期生成的常量，还允许动态生成，例如 String 类的 intern()。</p>
</li>
</ol>
<p><strong>运行时常量池的变动：</strong></p>
<ul>
<li>JDK1.7 之前运行时常量池逻辑包含字符串常量池存放在方法区, 此时 hotspot 虚拟机对方法区的实现为永久代</li>
<li>JDK1.7 字符串常量池被从方法区拿到了堆中, 这里没有提到运行时常量池,也就是说字符串常量池被单独拿到堆,运行时常量池剩下的东西还在方法区, 也就是 hotspot 中的永久代 。</li>
<li>JDK1.8 hotspot 移除了永久代用元空间(Metaspace)取而代之, 这时候字符串常量池还在堆, 运行时常量池还在方法区, 只不过方法区的实现从永久代变成了元空间(Metaspace)</li>
</ul>
<h2 id="1-7-直接内存"><a href="#1-7-直接内存" class="headerlink" title="1.7.    直接内存"></a>1.7.    直接内存</h2><p><strong>直接内存并不是虚拟机运行时数据区的一部分，也不是虚拟机规范中定义的内存区域，但是这部分内存也被频繁地使用。而且也可能导致 OutOfMemoryError 错误出现。</strong></p>
<p>在 JDK 1.4 中新引入了 NIO 类，它可以使用 Native 函数库直接分配堆外内存，然后通过 Java 堆里的 DirectByteBuffer 对象作为这块内</p>
<p>存的引用进行操作。这样能在一些场景中显著提高性能，因为避免了在堆内存和堆外内存来回拷贝数据。</p>
<p>本机直接内存的分配不会受到 Java 堆的限制，但是，既然是内存就会受到本机总内存大小以及处理器寻址空间的限制。</p>
<h1 id="2-HotSpot虚拟机对象"><a href="#2-HotSpot虚拟机对象" class="headerlink" title="2.   HotSpot虚拟机对象"></a>2.   HotSpot虚拟机对象</h1><h2 id="2-1-对象的创建过程"><a href="#2-1-对象的创建过程" class="headerlink" title="2.1. 对象的创建过程"></a>2.1. 对象的创建过程</h2><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://raw.githubusercontent.com/xdmqp/myPic/main/img/Java%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E7%9A%84%E8%BF%87%E7%A8%8B.png" alt="Java创建对象的过程" title="">
                </div>
                <div class="image-caption">Java创建对象的过程</div>
            </figure>

<h3 id="2-1-1-类加载检查"><a href="#2-1-1-类加载检查" class="headerlink" title="2.1.1. 类加载检查"></a>2.1.1. 类加载检查</h3><p>虚拟机遇到new指令时，首先<strong>检查这个指令的参数能否在常量池定位到这个类的符号引用，并且检查这个符号引用代表的类是否已经被加载、解析和初始化过，如果没有，那必须先执行类的加载过程。</strong></p>
<h3 id="2-1-2-分配内存"><a href="#2-1-2-分配内存" class="headerlink" title="2.1.2. 分配内存"></a>2.1.2. 分配内存</h3><p>在<strong>类加载检查</strong>通过后，接下来虚拟机将为新生对象<strong>分配内存</strong>。对象所需的内存大小在类加载完成后便可确定，为对象分配空间的任务等同于把一块确定大小的内存从 Java 堆中划分出来。<strong>分配方式</strong>有 <strong>“指针碰撞”</strong> 和 <strong>“空闲列表”</strong> 两种，<strong>选择哪种分配方式由 Java 堆是否规整决定，而 Java 堆是否规整又由所采用的垃圾收集器是“标记-清除”，还是“标记-整理”</strong>。</p>
<ul>
<li>指针碰撞：适用于堆内存规整的情况，将用过的内存全部整合到一边，没有用过的内存放在另一边，并维护一个分界值指针，每次分配内存时，从分界值指针向着没用过内存的方向移动对象内存大小位置。</li>
<li>空闲列表：适用于堆内存不规整的情况，虚拟机维护一个列表，用来几乎哪些内存块是可用的，在分配时，找到一块足够大的内存分配给对象实例，最后更新列表。</li>
</ul>
<p>空闲列表：</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://raw.githubusercontent.com/xdmqp/myPic/main/img/%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%96%B9%E5%BC%8F.png" alt="内存分配的两种方式" title="">
                </div>
                <div class="image-caption">内存分配的两种方式</div>
            </figure>

<p><strong>内存分配的并发问题</strong></p>
<p>虚拟机通过两种方式来保证线程安全：</p>
<ul>
<li><strong>CAS+失败重试：</strong>CAS是乐观锁的一种实现方式。每次假设没有冲突去完成某项操作，如果因为冲突失败重试，直到成功为止。<strong>虚拟机通过这种方式保证更新操作的原子性。</strong></li>
<li><strong>TLAB（线程本地分配缓存区）</strong>：为每个线程预先在Eden区分配一块内存TLAB，每次为线程中的对象分配内存时，首先在TLAB分配，如果TLAB剩余内存不足，再采用CAS+失败重试的方式分配。</li>
</ul>
<h3 id="2-1-3-初始化零值"><a href="#2-1-3-初始化零值" class="headerlink" title="2.1.3. 初始化零值"></a>2.1.3. 初始化零值</h3><p>内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值（不包括对象头），<strong>这一步操作保证了对象的实例字段在 Java 代码中可以不赋初始值就直接使用，程序能访问到这些字段的数据类型所对应的零值。</strong></p>
<h3 id="2-1-4-设置对象头"><a href="#2-1-4-设置对象头" class="headerlink" title="2.1.4. 设置对象头"></a>2.1.4. 设置对象头</h3><p>初始化零值完成之后，<strong>虚拟机要对对象进行必要的设置</strong>，例如这个对象<strong>是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的 GC 分代年龄</strong>等信息。 <strong>这些信息存放在对象头中。</strong> 另外，根据虚拟机当前运行状态的不同，如是否启用偏向锁等，对象头会有不同的设置方式。</p>
<h3 id="2-1-5-执行init方法"><a href="#2-1-5-执行init方法" class="headerlink" title="2.1.5. 执行init方法"></a>2.1.5. 执行init方法</h3><p>在上面工作都完成之后，从虚拟机的视角来看，一个新的对象已经产生了，但从 Java 程序的视角来看，对象创建才刚开始，<code>&lt;init&gt;</code> 方法还没有执行，所有的字段都还为零。所以一般来说，执行 new 指令之后会接着执行 <code>&lt;init&gt;</code> 方法，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完全产生出来。</p>
<h2 id="2-2-对象内存布局"><a href="#2-2-对象内存布局" class="headerlink" title="2.2. 对象内存布局"></a>2.2. 对象内存布局</h2><p>在HotSpot中，对象在内存中的布局可以分为三部分：<strong>对象头、实例数据和对齐填充</strong>。</p>
<p><strong>Hotspot 虚拟机的对象头包括两部分信息</strong>，<strong>第一部分用于存储对象自身的运行时数据</strong>（哈希码、GC 分代年龄、锁状态标志等等），<strong>另一部分是类型指针</strong>，即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是那个类的实例。</p>
<p><strong>实例数据部分是对象真正存储的有效信息</strong>，也是在程序中所定义的各种类型的字段内容。</p>
<p><strong>对齐填充部分不是必然存在的，也没有什么特别的含义，仅仅起占位作用。</strong> 因为 Hotspot 虚拟机的自动内存管理系统要求对象起始地址必须是 8 字节的整数倍，换句话说就是对象的大小必须是 8 字节的整数倍。而对象头部分正好是 8 字节的倍数（1 倍或 2 倍），因此，当对象实例数据部分没有对齐时，就需要通过对齐填充来补全。</p>
<h2 id="2-3-对象的访问定位方式"><a href="#2-3-对象的访问定位方式" class="headerlink" title="2.3.  对象的访问定位方式"></a>2.3.  对象的访问定位方式</h2><p>Java程序通过栈上的 reference 数据来操作堆上的具体对象。对象的访问方式有虚拟机实现而定，目前主流的访问方式有使用句柄和直接指针两种</p>
<h3 id="2-3-1-使用句柄"><a href="#2-3-1-使用句柄" class="headerlink" title="2.3.1.  使用句柄"></a>2.3.1.  使用句柄</h3><p>使用句柄的话，那么Java堆中将会划分出一块内存来作为句柄池，reference 中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自的具体地址信息</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://raw.githubusercontent.com/xdmqp/myPic/main/img/%E5%AF%B9%E8%B1%A1%E7%9A%84%E8%AE%BF%E9%97%AE%E5%AE%9A%E4%BD%8D-%E4%BD%BF%E7%94%A8%E5%8F%A5%E6%9F%84.png" alt="对象的访问定位-使用句柄" title="">
                </div>
                <div class="image-caption">对象的访问定位-使用句柄</div>
            </figure>

<h3 id="2-3-2-直接指针"><a href="#2-3-2-直接指针" class="headerlink" title="2.3.2.  直接指针"></a>2.3.2.  直接指针</h3><p>使用直接指针访问，那么 Java 堆对象的布局中就必须考虑如何放置访问类型数据的相关信息，而reference 中存储的直接就是对象的地址。</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://raw.githubusercontent.com/xdmqp/myPic/main/img/%E5%AF%B9%E8%B1%A1%E7%9A%84%E8%AE%BF%E9%97%AE%E5%AE%9A%E4%BD%8D-%E7%9B%B4%E6%8E%A5%E6%8C%87%E9%92%88.png" alt="对象的访问定位-直接指针" title="">
                </div>
                <div class="image-caption">对象的访问定位-直接指针</div>
            </figure>

<h3 id="2-3-3-对比"><a href="#2-3-3-对比" class="headerlink" title="2.3.3.  对比"></a>2.3.3.  对比</h3><p>这两种对象访问方式各有优势。<strong>使用句柄来访问的最大好处是 reference 中存储的是稳定的句柄地址，在对象被移动时只会改变句柄中的实例数据指针，而 reference 本身不需要修改。使用直接指针访问方式最大的好处就是速度快，它节省了一次指针定位的时间开销。</strong></p>
<h1 id="3-垃圾收集"><a href="#3-垃圾收集" class="headerlink" title="3.   垃圾收集"></a><strong>3.   垃圾收集</strong></h1><p>垃圾收集主要是针对堆和方法区进行。程序计数器、虚拟机栈和本地方法栈这三个区域属于线程私有的，只存在于线程的生命周期内，线程结束之后就会消失，因此不需要对这三个区域进行垃圾回收。</p>
<h2 id="3-1-判断一个对象是否可被回收"><a href="#3-1-判断一个对象是否可被回收" class="headerlink" title="3.1.    判断一个对象是否可被回收"></a>3.1.    判断一个对象是否可被回收</h2><h3 id="3-1-1-引用计数算法"><a href="#3-1-1-引用计数算法" class="headerlink" title="3.1.1.  引用计数算法"></a>3.1.1.  引用计数算法</h3><p>为对象添加一个引用计数器，当对象增加一个引用时计数器加 1，引用失效时计数器减 1。引用计数为 0 的对象可被回收。<br> 在两个对象出现循环引用的情况下，此时引用计数器永远不为 0，导致无法对它们进行回收。正是因为循环引用的存在，因此 Java 虚拟机不使用引用计数算法。</p>
<h3 id="3-1-2-可达性分析算法"><a href="#3-1-2-可达性分析算法" class="headerlink" title="3.1.2.  可达性分析算法"></a>3.1.2.  可达性分析算法</h3><p>以 GC Roots 为起始点进行搜索，可达的对象都是存活的，不可达的对象可被回收。<br> Java 虚拟机使用该算法来判断对象是否可被回收，GC Roots 一般包含以下内容：<br> 虚拟机栈中局部变量表中引用的对象<br> 本地方法栈中 JNI 中引用的对象<br> 方法区中类静态属性引用的对象<br> 方法区中的常量引用的对象</p>
<h3 id="3-1-3-方法区回收"><a href="#3-1-3-方法区回收" class="headerlink" title="3.1.3.  方法区回收"></a>3.1.3.  方法区回收</h3><p>因为方法区主要存放永久代对象，而永久代对象的回收率比新生代低很多，所以在方法区上进行回收性价比不高。<br> 主要是对常量池的回收和对类的卸载。<br> 为了避免内存溢出，在大量使用反射和动态代理的场景都需要虚拟机具备类卸载功能。<br> 类的卸载条件很多，需要满足以下三个条件，并且满足了条件也不一定会被卸载：<br> 该类所有的实例都已经被回收，此时堆中不存在该类的任何实例。<br> 加载该类的 ClassLoader 已经被回收。<br> 该类对应的 Class 对象没有在任何地方被引用，也就无法在任何地方通过反射访问该类方法。</p>
<h3 id="3-1-4-finalize"><a href="#3-1-4-finalize" class="headerlink" title="3.1.4.  finalize()"></a>3.1.4.  finalize()</h3><p>类似 C++ 的析构函数，用于关闭外部资源。但是 try-finally 等方式可以做得更好，并且该方法运行代价很高，不确定性大，无法保证各个对象的调用顺序，因此最好不要使用。<br> 当一个对象可被回收时，如果需要执行该对象的 finalize() 方法，那么就有可能在该方法中让对象重新被引用，从而实现自救。自救只能进行一次，如果回收的对象之前调用了 finalize() 方法自救，后面回收时不会再调用该方法。</p>
<h2 id="3-2-引用类型"><a href="#3-2-引用类型" class="headerlink" title="3.2.    引用类型"></a>3.2.    引用类型</h2><h3 id="3-2-1-强引用"><a href="#3-2-1-强引用" class="headerlink" title="3.2.1.  强引用"></a>3.2.1.  强引用</h3><p>被强引用关联的对象不会被回收。<br> 使用 new 一个新对象的方式来创建强引用。</p>
<h3 id="3-2-2-软引用"><a href="#3-2-2-软引用" class="headerlink" title="3.2.2.  软引用"></a>3.2.2.  软引用</h3><p>被软引用关联的对象只有在内存不够的情况下才会被回收。<br> 使用 SoftReference 类来创建软引用。</p>
<h3 id="3-2-3-弱引用"><a href="#3-2-3-弱引用" class="headerlink" title="3.2.3.  弱引用"></a>3.2.3.  弱引用</h3><p>被弱引用关联的对象一定会被回收，也就是说它只能存活到下一次垃圾回收发生之前。<br> 使用 WeakReference 类来创建弱引用。</p>
<h3 id="3-2-4-虚引用"><a href="#3-2-4-虚引用" class="headerlink" title="3.2.4.  虚引用"></a>3.2.4.  虚引用</h3><p>又称为幽灵引用或者幻影引用，一个对象是否有虚引用的存在，不会对其生存时间造成影响，也无法通过虚引用得到一个对象。<br> 为一个对象设置虚引用的唯一目的是能在这个对象被回收时收到一个系统通知。<br> 使用 PhantomReference 来创建虚引用。</p>
<h2 id="3-3-垃圾收集算法"><a href="#3-3-垃圾收集算法" class="headerlink" title="3.3.    垃圾收集算法"></a>3.3.    垃圾收集算法</h2><h3 id="3-3-1-标记-清除"><a href="#3-3-1-标记-清除" class="headerlink" title="3.3.1.  标记-清除"></a>3.3.1.  标记-清除</h3><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://raw.githubusercontent.com/xdmqp/myPic/main/img/clip_image002.png" alt="desc" title="">
                </div>
                <div class="image-caption">desc</div>
            </figure>

<p>在标记阶段，程序会检查每个对象是否为活动对象，如果是活动对象，则程序会在对象头部打上标记。<br> 在清除阶段，会进行对象回收并取消标志位，另外，还会判断回收后的分块与前一个空闲分块是否连续，若连续，会合并这两个分块。回收对象就是把对象作为分块，连接到被称为 “空闲链表” 的单向链表，之后进行分配时只需要遍历这个空闲链表，就可以找到分块。<br> 在分配时，程序会搜索空闲链表寻找空间大于等于新对象大小 size 的块 block。如果它找到的块等于 size，会直接返回这个分块；如果找到的块大于 size，会将块分割成大小为 size 与 (block - size) 的两部分，返回大小为 size 的分块，并把大小为 (block - size) 的块返回给空闲链表。<br> 不足：<br> 标记和清除过程效率都不高；<br> 会产生大量不连续的内存碎片，导致无法给大对象分配内存</p>
<h3 id="3-3-2-标记-整理"><a href="#3-3-2-标记-整理" class="headerlink" title="3.3.2.  标记-整理"></a>3.3.2.  标记-整理</h3><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://raw.githubusercontent.com/xdmqp/myPic/main/img/clip_image004.png" alt="desc" title="">
                </div>
                <div class="image-caption">desc</div>
            </figure>

<p>让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。<br> 优点：不会产生内存碎片<br> 不足：需要移动大量对象，处理效率比较低</p>
<h3 id="3-3-3-标记-复制"><a href="#3-3-3-标记-复制" class="headerlink" title="3.3.3.  标记-复制"></a>3.3.3.  标记-复制</h3><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://raw.githubusercontent.com/xdmqp/myPic/main/img/clip_image006.png" alt="desc" title="">
                </div>
                <div class="image-caption">desc</div>
            </figure>

<p>将内存划分为大小相等的两块，每次只使用其中一块，当这一块内存用完了就将还存活的对象复制到另一块上面，然后再把使用过的内存空间进行一次清理。<br> 主要不足是只使用了内存的一半。<br> 现在的商业虚拟机都采用这种收集算法回收新生代，但是并不是划分为大小相等的两块，而是一块较大的 Eden 空间和两块较小的 Survivor 空间，每次使用 Eden 和其中一块 Survivor。在回收时，将 Eden 和 Survivor 中还存活着的对象全部复制到另一块 Survivor 上，最后清理 Eden 和使用过的那一块 Survivor。<br> HotSpot 虚拟机的 Eden 和 Survivor 大小比例默认为 8:1，保证了内存的利用率达到 90%。如果每次回收有多于 10% 的对象存活，那么一块 Survivor 就不够用了，此时需要依赖于老年代进行空间分配担保，也就是借用老年代的空间存储放不下的对象。</p>
<h3 id="3-3-4-分代收集"><a href="#3-3-4-分代收集" class="headerlink" title="3.3.4.  分代收集"></a>3.3.4.  分代收集</h3><p>现在的商业虚拟机采用分代收集算法，它根据对象存活周期将内存划分为几块，不同块采用适当的收集算法。<br> 一般将堆分为新生代和老年代。<br> 新生代使用：复制算法<br> 老年代使用：标记-清除或者标记-整理</p>
<h2 id="3-4-垃圾收集器"><a href="#3-4-垃圾收集器" class="headerlink" title="3.4.    垃圾收集器"></a>3.4.    垃圾收集器</h2><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://raw.githubusercontent.com/xdmqp/myPic/main/img/clip_image008.png" alt="desc" title="">
                </div>
                <div class="image-caption">desc</div>
            </figure>

<p>以上是 HotSpot 虚拟机中的 7 个垃圾收集器，连线表示垃圾收集器可以配合使用。<br> 单线程与多线程：单线程指的是垃圾收集器只使用一个线程，而多线程使用多个线程；<br> 串行与并行：串行指的是垃圾收集器与用户程序交替执行，这意味着在执行垃圾收集的时候需要停顿用户程序；并行指的是垃圾收集器和用户程序同时执行。除了 CMS 和 G1 之外，其它垃圾收集器都是以串行的方式执行。</p>
<h3 id="3-4-1-1-Serial收集器"><a href="#3-4-1-1-Serial收集器" class="headerlink" title="3.4.1.  1.Serial收集器"></a>3.4.1.  1.Serial收集器</h3><p>Serial 翻译为串行，也就是说它以串行的方式执行。<br> 它是单线程的收集器，只会使用一个线程进行垃圾收集工作。<br> 它的优点是简单高效，在单个 CPU 环境下，由于没有线程交互的开销，因此拥有最高的单线程收集效率。<br> 它是 Client 场景下的默认新生代收集器，因为在该场景下内存一般来说不会很大。它收集一两百兆垃圾的停顿时间可以控制在一百多毫秒以内，只要不是太频繁，这点停顿时间是可以接受的。</p>
<h3 id="3-4-2-2-ParNew收集器"><a href="#3-4-2-2-ParNew收集器" class="headerlink" title="3.4.2.  2.ParNew收集器"></a>3.4.2.  2.ParNew收集器</h3><p>它是 Serial 收集器的多线程版本。<br> 它是 Server 场景下默认的新生代收集器，除了性能原因外，主要是因为除了 Serial 收集器，只有它能与 CMS 收集器配合使用。</p>
<h3 id="3-4-3-3-Parallel-Scavenge-收集器"><a href="#3-4-3-3-Parallel-Scavenge-收集器" class="headerlink" title="3.4.3.  3.Parallel Scavenge 收集器"></a>3.4.3.  3.Parallel Scavenge 收集器</h3><p>与 ParNew 一样是多线程收集器。<br> 其它收集器目标是尽可能缩短垃圾收集时用户线程的停顿时间，而它的目标是达到一个可控制的吞吐量，因此它被称为“吞吐量优先”收集器。这里的吞吐量指 CPU 用于运行用户程序的时间占总时间的比值。<br> 停顿时间越短就越适合需要与用户交互的程序，良好的响应速度能提升用户体验。而高吞吐量则可以高效率地利用 CPU 时间，尽快完成程序的运算任务，适合在后台运算而不需要太多交互的任务。<br> 缩短停顿时间是以牺牲吞吐量和新生代空间来换取的：新生代空间变小，垃圾回收变得频繁，导致吞吐量下降。<br> 可以通过一个开关参数打开 GC 自适应的调节策略（GC Ergonomics），就不需要手工指定新生代的大小（-Xmn）、Eden 和 Survivor 区的比例、晋升老年代对象年龄等细节参数了。虚拟机会根据当前系统的运行情况收集性能监控信息，动态调整这些参数以提供最合适的停顿时间或者最大的吞吐量。</p>
<h3 id="3-4-4-4-Serial-Old收集器"><a href="#3-4-4-4-Serial-Old收集器" class="headerlink" title="3.4.4.  4.Serial Old收集器"></a>3.4.4.  4.Serial Old收集器</h3><p>是 Serial 收集器的老年代版本，也是给 Client 场景下的虚拟机使用。如果用在 Server 场景下，它有两大用途：<br> 在 JDK 1.5 以及之前版本（Parallel Old 诞生以前）中与 Parallel Scavenge 收集器搭配使用。<br> 作为 CMS 收集器的后备预案，在并发收集发生 Concurrent Mode Failure 时使用。</p>
<h3 id="3-4-5-5-Parallel-Old收集器"><a href="#3-4-5-5-Parallel-Old收集器" class="headerlink" title="3.4.5.  5.Parallel Old收集器"></a>3.4.5.  5.Parallel Old收集器</h3><p>是 Parallel Scavenge 收集器的老年代版本。<br> 在注重吞吐量以及 CPU 资源敏感的场合，都可以优先考虑 Parallel Scavenge 加 Parallel Old 收集器。</p>
<h3 id="3-4-6-6-CMS收集器"><a href="#3-4-6-6-CMS收集器" class="headerlink" title="3.4.6.  6.CMS收集器"></a>3.4.6.  6.CMS收集器</h3><p>CMS（Concurrent Mark Sweep），Mark Sweep 指的是标记 - 清除算法。<br> 分为以下四个流程：<br> 初始标记：仅仅只是标记一下 GC Roots 能直接关联到的对象，速度很快，需要停顿。<br> 并发标记：进行 GC Roots Tracing 的过程，它在整个回收过程中耗时最长，不需要停顿。<br> 重新标记：为了修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，需要停顿。<br> 并发清除：不需要停顿。<br> 在整个过程中耗时最长的并发标记和并发清除过程中，收集器线程都可以与用户线程一起工作，不需要进行停顿。<br> 具有以下缺点：<br> 吞吐量低：低停顿时间是以牺牲吞吐量为代价的，导致 CPU 利用率不够高。<br> 无法处理浮动垃圾，可能出现 Concurrent Mode Failure。浮动垃圾是指并发清除阶段由于用户线程继续运行而产生的垃圾，这部分垃圾只能到下一次 GC 时才能进行回收。由于浮动垃圾的存在，因此需要预留出一部分内存，意味着 CMS 收集不能像其它收集器那样等待老年代快满的时候再回收。如果预留的内存不够存放浮动垃圾，就会出现 Concurrent Mode Failure，这时虚拟机将临时启用 Serial Old 来替代 CMS。<br> 标记 - 清除算法导致的空间碎片，往往出现老年代空间剩余，但无法找到足够大连续空间来分配当前对象，不得不提前触发一次 Full GC。</p>
<h3 id="3-4-7-7-G1收集器"><a href="#3-4-7-7-G1收集器" class="headerlink" title="3.4.7.  7.G1收集器"></a>3.4.7.  7.G1收集器</h3><p>G1（Garbage-First），它是一款面向服务端应用的垃圾收集器，在多 CPU 和大内存的场景下有很好的性能。HotSpot 开发团队赋予它的使命是未来可以替换掉 CMS 收集器。<br> 堆被分为新生代和老年代，其它收集器进行收集的范围都是整个新生代或者老年代，而 G1 可以直接对新生代和老年代一起回收。<br> G1 把堆划分成多个大小相等的独立区域（Region），新生代和老年代不再物理隔离。<br> 通过引入 Region 的概念，从而将原来的一整块内存空间划分成多个的小空间，使得每个小空间可以单独进行垃圾回收。这种划分方法带来了很大的灵活性，使得可预测的停顿时间模型成为可能。通过记录每个 Region 垃圾回收时间以及回收所获得的空间（这两个值是通过过去回收的经验获得），并维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的 Region。<br> 每个 Region 都有一个 Remembered Set，用来记录该 Region 对象的引用对象所在的 Region。通过使用 Remembered Set，在做可达性分析的时候就可以避免全堆扫描。<br> 如果不计算维护 Remembered Set 的操作，G1 收集器的运作大致可划分为以下几个步骤：<br> 初始标记<br> 并发标记<br> 最终标记：为了修正在并发标记期间因用户程序继续运作而导致标记产生变动的那一部分标记记录，虚拟机将这段时间对象变化记录在线程的 Remembered Set Logs 里面，最终标记阶段需要把 Remembered Set Logs 的数据合并到 Remembered Set 中。这阶段需要停顿线程，但是可并行执行。<br> 筛选回收：首先对各个 Region 中的回收价值和成本进行排序，根据用户所期望的 GC 停顿时间来制定回收计划。此阶段其实也可以做到与用户程序一起并发执行，但是因为只回收一部分 Region，时间是用户可控制的，而且停顿用户线程将大幅度提高收集效率。<br> 具备如下特点：<br> 空间整合：整体来看是基于“标记 - 整理”算法实现的收集器，从局部（两个 Region 之间）上来看是基于“复制”算法实现的，这意味着运行期间不会产生内存空间碎片。<br> 可预测的停顿：能让使用者明确指定在一个长度为 M 毫秒的时间片段内，消耗在 GC 上的时间不得超过 N 毫秒。</p>
<h3 id="3-4-8-8-ZGC收集器"><a href="#3-4-8-8-ZGC收集器" class="headerlink" title="3.4.8.  8.ZGC收集器"></a>3.4.8.  8.ZGC收集器</h3><h1 id="4-内存分配与回收"><a href="#4-内存分配与回收" class="headerlink" title="4.   内存分配与回收"></a>4.   内存分配与回收</h1><h2 id="4-1-Minor-GC和Full-GC"><a href="#4-1-Minor-GC和Full-GC" class="headerlink" title="4.1.    Minor GC和Full GC"></a>4.1.    Minor GC和Full GC</h2><p>Minor GC：回收新生代，因为新生代对象存活时间很短，因此 Minor GC 会频繁执行，执行的速度一般也会比较快。<br> Full GC：回收老年代和新生代，老年代对象其存活时间长，因此 Full GC 很少执行，执行速度会比 Minor GC 慢很多。</p>
<h2 id="4-2-内存分配策略"><a href="#4-2-内存分配策略" class="headerlink" title="4.2.    内存分配策略"></a>4.2.    内存分配策略</h2><h3 id="4-2-1-1-对象优先在Eden分配"><a href="#4-2-1-1-对象优先在Eden分配" class="headerlink" title="4.2.1.  1.对象优先在Eden分配"></a>4.2.1.  1.对象优先在Eden分配</h3><p>大多数情况下，对象在新生代 Eden 上分配，当 Eden 空间不够时，发起 Minor GC。</p>
<h3 id="4-2-2-2-大对象直接进入老年代"><a href="#4-2-2-2-大对象直接进入老年代" class="headerlink" title="4.2.2.  2.大对象直接进入老年代"></a>4.2.2.  2.大对象直接进入老年代</h3><p>大对象是指需要连续内存空间的对象，最典型的大对象是那种很长的字符串以及数组。<br> 经常出现大对象会提前触发垃圾收集以获取足够的连续空间分配给大对象。<br> -XX:PretenureSizeThreshold，大于此值的对象直接在老年代分配，避免在 Eden 和 Survivor 之间的大量内存复制。</p>
<h3 id="4-2-3-3-长期存活的对象进入老年代"><a href="#4-2-3-3-长期存活的对象进入老年代" class="headerlink" title="4.2.3.  3.长期存活的对象进入老年代"></a>4.2.3.  3.长期存活的对象进入老年代</h3><p>为对象定义年龄计数器，对象在 Eden 出生并经过 Minor GC 依然存活，将移动到 Survivor 中，年龄就增加 1 岁，增加到一定年龄则移动到老年代中。<br> -XX:MaxTenuringThreshold 用来定义年龄的阈值。</p>
<h3 id="4-2-4-4-动态对象年龄判定"><a href="#4-2-4-4-动态对象年龄判定" class="headerlink" title="4.2.4.  4.动态对象年龄判定"></a>4.2.4.  4.动态对象年龄判定</h3><p>虚拟机并不是永远要求对象的年龄必须达到 MaxTenuringThreshold 才能晋升老年代，如果在 Survivor 中相同年龄所有对象大小的总和大于 Survivor 空间的一半，则年龄大于或等于该年龄的对象可以直接进入老年代，无需等到 MaxTenuringThreshold 中要求的年龄。</p>
<h3 id="4-2-5-5-空间分配担保"><a href="#4-2-5-5-空间分配担保" class="headerlink" title="4.2.5.  5.空间分配担保"></a>4.2.5.  5.空间分配担保</h3><p>在发生 Minor GC 之前，虚拟机先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果条件成立的话，那么 Minor GC 可以确认是安全的。<br> 如果不成立的话虚拟机会查看 HandlePromotionFailure 的值是否允许担保失败，如果允许那么就会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试着进行一次 Minor GC；如果小于，或者 HandlePromotionFailure 的值不允许冒险，那么就要进行一次 Full GC。</p>
<h2 id="4-3-Full-GC的触发条件"><a href="#4-3-Full-GC的触发条件" class="headerlink" title="4.3.    Full GC的触发条件"></a>4.3.    Full GC的触发条件</h2><p>对于 Minor GC，其触发条件非常简单，当 Eden 空间满时，就将触发一次 Minor GC。而 Full GC 则相对复杂，有以下条件：<br> 调用System.gc()：只是建议虚拟机执行 Full GC，但是虚拟机不一定真正去执行。不建议使用这种方式，而是让虚拟机管理内存。<br> 老年代空间不足：老年代空间不足的常见场景为前文所讲的大对象直接进入老年代、长期存活的对象进入老年代等。为了避免以上原因引起的 Full GC，应当尽量不要创建过大的对象以及数组。除此之外，可以通过 -Xmn 虚拟机参数调大新生代的大小，让对象尽量在新生代被回收掉，不进入老年代。还可以通过 -XX:MaxTenuringThreshold 调大对象进入老年代的年龄，让对象在新生代多存活一段时间。<br> 空间分配担保失败：使用复制算法的 Minor GC 需要老年代的内存空间作担保，如果担保失败会执行一次 Full GC。<br> JDK1.7及以前的永久代空间不足：在 JDK 1.7 及以前，HotSpot 虚拟机中的方法区是用永久代实现的，永久代中存放的为一些 Class 的信息、常量、静态变量等数据。当系统中要加载的类、反射的类和调用的方法较多时，永久代可能会被占满，在未配置为采用 CMS GC 的情况下也会执行 Full GC。如果经过 Full GC 仍然回收不了，那么虚拟机会抛出 java.lang.OutOfMemoryError。为避免以上原因引起的 Full GC，可采用的方法为增大永久代空间或转为使用 CMS GC。<br> Concurrent Mode Failure：执行 CMS GC 的过程中同时有对象要放入老年代，而此时老年代空间不足（可能是 GC 过程中浮动垃圾过多导致暂时性的空间不足），便会报 Concurrent Mode Failure 错误，并触发 Full GC。</p>
<h1 id="5-类加载机制"><a href="#5-类加载机制" class="headerlink" title="5.   类加载机制"></a>5.   类加载机制</h1><p>类是在运行期间第一次使用时动态加载的，而不是一次性加载所有类。因为如果一次性加载，那么会占用很多的内存。</p>
<h2 id="5-1-类的生命周期"><a href="#5-1-类的生命周期" class="headerlink" title="5.1.    类的生命周期"></a>5.1.    类的生命周期</h2><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://raw.githubusercontent.com/xdmqp/myPic/main/img/335fe19c-4a76-45ab-9320-88c90d6a0d7e.png" alt="img" title="">
                </div>
                <div class="image-caption">img</div>
            </figure>

<p>包含7个阶段：加载、验证、准备、解析、初始化、使用、卸载</p>
<h2 id="5-2-类加载过程"><a href="#5-2-类加载过程" class="headerlink" title="5.2.    类加载过程"></a>5.2.    类加载过程</h2><h3 id="5-2-1-加载"><a href="#5-2-1-加载" class="headerlink" title="5.2.1.  加载"></a>5.2.1.  加载</h3><p>加载是类加载的一个阶段，注意不要混淆。<br> 加载过程完成三件事：<br> 通过类的完全限定名称获取定义该类的二进制字节流。<br> 将该字节流表示的静态存储结构转换为方法区的运行时存储结构。<br> 在内存中生成一个代表该类的 Class 对象，作为方法区中该类各种数据的访问入口。</p>
<h3 id="5-2-2-验证"><a href="#5-2-2-验证" class="headerlink" title="5.2.2.  验证"></a>5.2.2.  验证</h3><p>确保 Class 文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。</p>
<h3 id="5-2-3-准备"><a href="#5-2-3-准备" class="headerlink" title="5.2.3.  准备"></a>5.2.3.  准备</h3><p>类变量是被 static 修饰的变量，准备阶段为类变量分配内存并设置初始值，使用的是方法区的内存。<br> 实例变量不会在这阶段分配内存，它会在对象实例化时随着对象一起被分配在堆中。应该注意到，实例化不是类加载的一个过程，类加载发生在所有实例化操作之前，并且类加载只进行一次，实例化可以进行多次。<br> 初始值一般为0值，如果类常量是常量（final修饰），那么将初始化为表达式所定义的值而不是 0。</p>
<h3 id="5-2-4-解析"><a href="#5-2-4-解析" class="headerlink" title="5.2.4.  解析"></a>5.2.4.  解析</h3><p>将常量池的符号引用替换为直接引用的过程。<br> 其中解析过程在某些情况下可以在初始化阶段之后再开始，这是为了支持 Java 的动态绑定。</p>
<h3 id="5-2-5-初始化"><a href="#5-2-5-初始化" class="headerlink" title="5.2.5.  初始化"></a>5.2.5.  初始化</h3><p>初始化阶段才真正开始执行类中定义的 Java 程序代码。初始化阶段是虚拟机执行类构造器 <clinit>() 方法的过程。在准备阶段，类变量已经赋过一次系统要求的初始值，而在初始化阶段，根据程序员通过程序制定的主观计划去初始化类变量和其它资源。<br> <clinit>() 是由编译器自动收集类中所有类变量的赋值动作和静态语句块中的语句合并产生的，编译器收集的顺序由语句在源文件中出现的顺序决定。特别注意的是，静态语句块只能访问到定义在它之前的类变量，定义在它之后的类变量只能赋值，不能访问。<br> 由于父类的 <clinit>() 方法先执行，也就意味着父类中定义的静态语句块的执行要优先于子类。<br> 接口中不可以使用静态语句块，但仍然有类变量初始化的赋值操作，因此接口与类一样都会生成 <clinit>() 方法。但接口与类不同的是，执行接口的 <clinit>() 方法不需要先执行父接口的 <clinit>() 方法。只有当父接口中定义的变量使用时，父接口才会初始化。另外，接口的实现类在初始化时也一样不会执行接口的 <clinit>() 方法。<br> 虚拟机会保证一个类的 <clinit>() 方法在多线程环境下被正确的加锁和同步，如果多个线程同时初始化一个类，只会有一个线程执行这个类的 <clinit>() 方法，其它线程都会阻塞等待，直到活动线程执行 <clinit>() 方法完毕。如果在一个类的 <clinit>() 方法中有耗时的操作，就可能造成多个线程阻塞，在实际过程中此种阻塞很隐蔽。</p>
<h2 id="5-3-类初始化时机"><a href="#5-3-类初始化时机" class="headerlink" title="5.3.    类初始化时机"></a>5.3.    类初始化时机</h2><h3 id="5-3-1-主动引用"><a href="#5-3-1-主动引用" class="headerlink" title="5.3.1.  主动引用"></a>5.3.1.  主动引用</h3><p>虚拟机规范中并没有强制约束何时进行加载，但是规范严格规定了有且只有下列五种情况必须对类进行初始化（加载、验证、准备都会随之发生）：<br> 遇到 new、getstatic、putstatic、invokestatic 这四条字节码指令时，如果类没有进行过初始化，则必须先触发其初始化。最常见的生成这 4 条指令的场景是：使用 new 关键字实例化对象的时候；读取或设置一个类的静态字段（被 final 修饰、已在编译期把结果放入常量池的静态字段除外）的时候；以及调用一个类的静态方法的时候。<br> 使用 java.lang.reflect 包的方法对类进行反射调用的时候，如果类没有进行初始化，则需要先触发其初始化。<br> 当初始化一个类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化。<br> 当虚拟机启动时，用户需要指定一个要执行的主类（包含 main() 方法的那个类），虚拟机会先初始化这个主类；<br> 当使用 JDK 1.7 的动态语言支持时，如果一个 java.lang.invoke.MethodHandle 实例最后的解析结果为 REF_getStatic, REF_putStatic, REF_invokeStatic 的方法句柄，并且这个方法句柄所对应的类没有进行过初始化，则需要先触发其初始化；</p>
<h3 id="5-3-2-被动引用"><a href="#5-3-2-被动引用" class="headerlink" title="5.3.2.  被动引用"></a>5.3.2.  被动引用</h3><p>以上 5 种场景中的行为称为对一个类进行主动引用。除此之外，所有引用类的方式都不会触发初始化，称为被动引用。被动引用的常见例子包括：<br> 通过子类引用父类的静态字段，不会导致子类初始化。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(SubClass.value);  <span class="comment">// value 字段在 SuperClass 中定义</span></span><br></pre></td></tr></table></figure>

<p> 通过数组定义来引用类，不会触发此类的初始化。该过程会对数组类进行初始化，数组类是一个由虚拟机自动生成的、直接继承自 Object 的子类，其中包含了数组的属性和方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SuperClass[] sca = <span class="keyword">new</span> SuperClass[<span class="number">10</span>];</span><br></pre></td></tr></table></figure>

<p> 常量在编译阶段会存入调用类的常量池中，本质上并没有直接引用到定义常量的类，因此不会触发定义常量的类的初始化。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(ConstClass.HELLOWORLD);</span><br></pre></td></tr></table></figure>

<h2 id="5-4-类与类加载器"><a href="#5-4-类与类加载器" class="headerlink" title="5.4.    类与类加载器"></a>5.4.    类与类加载器</h2><p>两个类相等，需要类本身相等，并且使用同一个类加载器进行加载。这是因为每一个类加载器都拥有一个独立的类名称空间。<br> 这里的相等，包括类的 Class 对象的 equals() 方法、isAssignableFrom() 方法、isInstance() 方法的返回结果为 true，也包括使用 instanceof 关键字做对象所属关系判定结果为 true。</p>
<h2 id="5-5-类加载器分类"><a href="#5-5-类加载器分类" class="headerlink" title="5.5.    类加载器分类"></a>5.5.    类加载器分类</h2><p>从 Java 虚拟机的角度来讲，只存在以下两种不同的类加载器：<br> 启动类加载器（Bootstrap ClassLoader），使用 C++ 实现，是虚拟机自身的一部分；<br> 所有其它类的加载器，使用 Java 实现，独立于虚拟机，继承自抽象类 java.lang.ClassLoader。<br> 从 Java 开发人员的角度看，类加载器可以划分得更细致一些：<br> 启动类加载器（Bootstrap ClassLoader）此类加载器负责将存放在 <JRE_HOME>\lib 目录中的，或者被 -Xbootclasspath 参数所指定的路径中的，并且是虚拟机识别的（仅按照文件名识别，如 rt.jar，名字不符合的类库即使放在 lib 目录中也不会被加载）类库加载到虚拟机内存中。启动类加载器无法被 Java 程序直接引用，用户在编写自定义类加载器时，如果需要把加载请求委派给启动类加载器，直接使用 null 代替即可。<br> 扩展类加载器（Extension ClassLoader）这个类加载器是由 ExtClassLoader（sun.misc.Launcher$ExtClassLoader）实现的。它负责将 <JAVA_HOME>/lib/ext 或者被 java.ext.dir 系统变量所指定路径中的所有类库加载到内存中，开发者可以直接使用扩展类加载器。<br> 应用程序类加载器（Application ClassLoader）这个类加载器是由 AppClassLoader（sun.misc.Launcher$AppClassLoader）实现的。由于这个类加载器是 ClassLoader 中的 getSystemClassLoader() 方法的返回值，因此一般称为系统类加载器。它负责加载用户类路径（ClassPath）上所指定的类库，开发者可以直接使用这个类加载器，如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。</p>
<h2 id="5-6-双亲委派模型"><a href="#5-6-双亲委派模型" class="headerlink" title="5.6.    双亲委派模型"></a>5.6.    双亲委派模型</h2><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://raw.githubusercontent.com/xdmqp/myPic/main/img/0dd2d40a-5b2b-4d45-b176-e75a4cd4bdbf.png" alt="img" title="">
                </div>
                <div class="image-caption">img</div>
            </figure>

<p>应用程序是由三种类加载器互相配合从而实现类加载，除此之外还可以加入自己定义的类加载器。<br> 下图展示了类加载器之间的层次关系，称为双亲委派模型（Parents Delegation Model）。该模型要求除了顶层的启动类加载器外，其它的类加载器都要有自己的父类加载器。这里的父子关系一般通过组合关系（Composition）来实现，而不是继承关系（Inheritance）。</p>
<h3 id="5-6-1-工作过程"><a href="#5-6-1-工作过程" class="headerlink" title="5.6.1.  工作过程"></a>5.6.1.  工作过程</h3><p>一个类加载器首先将类加载请求转发到父类加载器，只有当父类加载器无法完成时才尝试自己加载。</p>
<h3 id="5-6-2-好处"><a href="#5-6-2-好处" class="headerlink" title="5.6.2.  好处"></a>5.6.2.  好处</h3><p>使得 Java 类随着它的类加载器一起具有一种带有优先级的层次关系，从而使得基础类得到统一。<br> 例如 java.lang.Object 存放在 rt.jar 中，如果编写另外一个 java.lang.Object 并放到 ClassPath 中，程序可以编译通过。由于双亲委派模型的存在，所以在 rt.jar 中的 Object 比在 ClassPath 中的 Object 优先级更高，这是因为 rt.jar 中的 Object 使用的是启动类加载器，而 ClassPath 中的 Object 使用的是应用程序类加载器。rt.jar 中的 Object 优先级更高，那么程序中所有的 Object 都是这个 Object。</p>
<h3 id="5-6-3-实现"><a href="#5-6-3-实现" class="headerlink" title="5.6.3.  实现"></a>5.6.3.  实现</h3><p>以下是抽象类 java.lang.ClassLoader 的代码片段，其中的 loadClass() 方法运行过程如下：先检查类是否已经加载过，如果没有则让父类加载器去加载。当父类加载器加载失败时抛出 ClassNotFoundException，此时尝试自己去加载。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassLoader</span> </span>&#123;</span><br><span class="line">    <span class="comment">// The parent class loader for delegation</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ClassLoader parent;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Class&lt;?&gt; loadClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        <span class="keyword">return</span> loadClass(name, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="keyword">boolean</span> resolve) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (getClassLoadingLock(name)) &#123;</span><br><span class="line">            <span class="comment">// First, check if the class has already been loaded</span></span><br><span class="line">            Class&lt;?&gt; c = findLoadedClass(name);</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        c = parent.loadClass(name, <span class="keyword">false</span>);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        c = findBootstrapClassOrNull(name);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">                    <span class="comment">// ClassNotFoundException thrown if class not found</span></span><br><span class="line">                    <span class="comment">// from the non-null parent class loader</span></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// If still not found, then invoke findClass in order</span></span><br><span class="line">                    <span class="comment">// to find the class.</span></span><br><span class="line">                    c = findClass(name);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (resolve) &#123;</span><br><span class="line">                resolveClass(c);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> c;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ClassNotFoundException(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="5-7-自定义类加载器实现"><a href="#5-7-自定义类加载器实现" class="headerlink" title="5.7.    自定义类加载器实现"></a>5.7.    自定义类加载器实现</h2><p>以下代码中的 FileSystemClassLoader 是自定义类加载器，继承自 java.lang.ClassLoader，用于加载文件系统上的类。它首先根据类的全名在文件系统上查找类的字节代码文件（.class 文件），然后读取该文件内容，最后通过 defineClass() 方法来把这些字节代码转换成 java.lang.Class 类的实例。</p>
<p>java.lang.ClassLoader 的 loadClass() 实现了双亲委派模型的逻辑，自定义类加载器一般不去重写它，但是需要重写 findClass() 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileSystemClassLoader</span> <span class="keyword">extends</span> <span class="title">ClassLoader</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String rootDir;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FileSystemClassLoader</span><span class="params">(String rootDir)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.rootDir = rootDir;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        <span class="keyword">byte</span>[] classData = getClassData(name);</span><br><span class="line">        <span class="keyword">if</span> (classData == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ClassNotFoundException();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> defineClass(name, classData, <span class="number">0</span>, classData.length);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">byte</span>[] getClassData(String className) &#123;</span><br><span class="line">        String path = classNameToPath(className);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            InputStream ins = <span class="keyword">new</span> FileInputStream(path);</span><br><span class="line">            ByteArrayOutputStream baos = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">            <span class="keyword">int</span> bufferSize = <span class="number">4096</span>;</span><br><span class="line">            <span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[bufferSize];</span><br><span class="line">            <span class="keyword">int</span> bytesNumRead;</span><br><span class="line">            <span class="keyword">while</span> ((bytesNumRead = ins.read(buffer)) != -<span class="number">1</span>) &#123;</span><br><span class="line">                baos.write(buffer, <span class="number">0</span>, bytesNumRead);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> baos.toByteArray();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">classNameToPath</span><span class="params">(String className)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> rootDir + File.separatorChar</span><br><span class="line">                + className.replace(<span class="string">'.'</span>, File.separatorChar) + <span class="string">".class"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>CS-Notes：<a href="https://www.cyc2018.xyz/Java/Java%20%E8%99%9A%E6%8B%9F%E6%9C%BA.html" target="_blank" rel="noopener">https://www.cyc2018.xyz/Java/Java%20%E8%99%9A%E6%8B%9F%E6%9C%BA.html</a></p>
</blockquote>

        </div>

        <blockquote class="post-copyright">
    
    <div class="content">
        

        
        这里可以写作者留言，标签和 hexo 中所有变量及辅助函数等均可调用，示例：<a href="/2021/03/14/Java%E8%99%9A%E6%8B%9F%E6%9C%BA/" target="_blank" rel="external">https://xdmqp.github.io/2021/03/14/Java%E8%99%9A%E6%8B%9F%E6%9C%BA/</a>
        
    </div>
    
    <footer>
        <a href="https://xdmqp.github.io">
            <img src="/img/avatar.jpg" alt="登高必自">
            登高必自
        </a>
    </footer>
</blockquote>

        


        <div class="post-footer">
            
	<ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JVM/" rel="tag">JVM</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/" rel="tag">Java</a></li></ul>


            
<div class="page-share-wrap">
    

<div class="page-share" id="pageShare">
    <ul class="reset share-icons">
      <li>
        <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=https://xdmqp.github.io/2021/03/14/Java%E8%99%9A%E6%8B%9F%E6%9C%BA/&title=《Java虚拟机》 — 我的技术笔记&pic=https://xdmqp.github.io/img/avatar.jpg" data-title="微博">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      <li>
        <a class="weixin share-sns wxFab" href="javascript:;" data-title="微信">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      <li>
        <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=https://xdmqp.github.io/2021/03/14/Java%E8%99%9A%E6%8B%9F%E6%9C%BA/&title=《Java虚拟机》 — 我的技术笔记&source=" data-title=" QQ">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      <li>
        <a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=https://xdmqp.github.io/2021/03/14/Java%E8%99%9A%E6%8B%9F%E6%9C%BA/" data-title=" Facebook">
          <i class="icon icon-facebook"></i>
        </a>
      </li>
      <li>
        <a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《Java虚拟机》 — 我的技术笔记&url=https://xdmqp.github.io/2021/03/14/Java%E8%99%9A%E6%8B%9F%E6%9C%BA/&via=https://xdmqp.github.io" data-title=" Twitter">
          <i class="icon icon-twitter"></i>
        </a>
      </li>
      <li>
        <a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=https://xdmqp.github.io/2021/03/14/Java%E8%99%9A%E6%8B%9F%E6%9C%BA/" data-title=" Google+">
          <i class="icon icon-google-plus"></i>
        </a>
      </li>
    </ul>
 </div>



    <a href="javascript:;" id="shareFab" class="page-share-fab waves-effect waves-circle">
        <i class="icon icon-share-alt icon-lg"></i>
    </a>
</div>



        </div>
    </div>

    
<nav class="post-nav flex-row flex-justify-between">
  
    <div class="waves-block waves-effect prev">
      <a href="/2021/06/19/Java%E9%9D%99%E6%80%81%E4%BB%A3%E7%90%86%E5%92%8C%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/" id="post-prev" class="post-nav-link">
        <div class="tips"><i class="icon icon-angle-left icon-lg icon-pr"></i> Prev</div>
        <h4 class="title">Java静态代理和动态代理</h4>
      </a>
    </div>
  

  
    <div class="waves-block waves-effect next">
      <a href="/2021/02/28/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%B1%87%E6%80%BB/" id="post-next" class="post-nav-link">
        <div class="tips">Next <i class="icon icon-angle-right icon-lg icon-pl"></i></div>
        <h4 class="title">排序算法汇总</h4>
      </a>
    </div>
  
</nav>



    




















</article>



</div>

        <footer class="footer">
    <div class="top">
        
<p>
    <span id="busuanzi_container_site_uv" style='display:none'>
        站点总访客数：<span id="busuanzi_value_site_uv"></span>
    </span>
    <span id="busuanzi_container_site_pv" style='display:none'>
        站点总访问量：<span id="busuanzi_value_site_pv"></span>
    </span>
</p>


        <p>
            
                <span><a href="/atom.xml" target="_blank" class="rss" title="rss"><i class="icon icon-lg icon-rss"></i></a></span>
            
            <span>博客内容遵循 <a rel="license noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" target="_blank">知识共享 署名 - 非商业性 - 相同方式共享 4.0 国际协议</a></span>
        </p>
    </div>
    <div class="bottom">
        <p><span>登高必自 &copy; 2019 - 2021</span>
            <span>
                
                Power by <a href="http://hexo.io/" target="_blank">Hexo</a> Theme <a href="https://github.com/yscoder/hexo-theme-indigo" target="_blank">indigo</a>
            </span>
        </p>
    </div>
</footer>

    </main>
    <div class="mask" id="mask"></div>
<a href="javascript:;" id="gotop" class="waves-effect waves-circle waves-light"><span class="icon icon-lg icon-chevron-up"></span></a>



<div class="global-share" id="globalShare">
    <ul class="reset share-icons">
      <li>
        <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=https://xdmqp.github.io/2021/03/14/Java%E8%99%9A%E6%8B%9F%E6%9C%BA/&title=《Java虚拟机》 — 我的技术笔记&pic=https://xdmqp.github.io/img/avatar.jpg" data-title="微博">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      <li>
        <a class="weixin share-sns wxFab" href="javascript:;" data-title="微信">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      <li>
        <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=https://xdmqp.github.io/2021/03/14/Java%E8%99%9A%E6%8B%9F%E6%9C%BA/&title=《Java虚拟机》 — 我的技术笔记&source=" data-title=" QQ">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      <li>
        <a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=https://xdmqp.github.io/2021/03/14/Java%E8%99%9A%E6%8B%9F%E6%9C%BA/" data-title=" Facebook">
          <i class="icon icon-facebook"></i>
        </a>
      </li>
      <li>
        <a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《Java虚拟机》 — 我的技术笔记&url=https://xdmqp.github.io/2021/03/14/Java%E8%99%9A%E6%8B%9F%E6%9C%BA/&via=https://xdmqp.github.io" data-title=" Twitter">
          <i class="icon icon-twitter"></i>
        </a>
      </li>
      <li>
        <a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=https://xdmqp.github.io/2021/03/14/Java%E8%99%9A%E6%8B%9F%E6%9C%BA/" data-title=" Google+">
          <i class="icon icon-google-plus"></i>
        </a>
      </li>
    </ul>
 </div>


<div class="page-modal wx-share" id="wxShare">
    <a class="close" href="javascript:;"><i class="icon icon-close"></i></a>
    <p>扫一扫，分享到微信</p>
    <img src="//api.qrserver.com/v1/create-qr-code/?data=https://xdmqp.github.io/2021/03/14/Java%E8%99%9A%E6%8B%9F%E6%9C%BA/" alt="微信分享二维码">
</div>




    <script src="//cdn.bootcss.com/node-waves/0.7.4/waves.min.js"></script>
<script>
var BLOG = { ROOT: '/', SHARE: true, REWARD: false };


</script>

<script src="//unpkg.com/hexo-theme-material-indigo@latest/js/main.min.js"></script>


<div class="search-panel" id="search-panel">
    <ul class="search-result" id="search-result"></ul>
</div>
<template id="search-tpl">
<li class="item">
    <a href="{path}" class="waves-block waves-effect">
        <div class="title ellipsis" title="{title}">{title}</div>
        <div class="flex-row flex-middle">
            <div class="tags ellipsis">
                {tags}
            </div>
            <time class="flex-col time">{date}</time>
        </div>
    </a>
</li>
</template>

<script src="//unpkg.com/hexo-theme-material-indigo@latest/js/search.min.js" async></script>



<!-- mathjax config similar to math.stackexchange -->

<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';
    }
});
</script>

<script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" async></script>




<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>





</body>
</html>
