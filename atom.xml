<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>我的技术笔记</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://xdmqp.github.io/"/>
  <updated>2021-07-10T15:07:24.706Z</updated>
  <id>https://xdmqp.github.io/</id>
  
  <author>
    <name>登高必自</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Java类文件结构</title>
    <link href="https://xdmqp.github.io/2021/07/10/class%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/"/>
    <id>https://xdmqp.github.io/2021/07/10/class%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/</id>
    <published>2021-07-09T16:00:00.000Z</published>
    <updated>2021-07-10T15:07:24.706Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>在Java中，能够被JVM理解的代码叫做字节码文件也就是.class文件。Java通过字节码的方式，在一定程度上解决了传统解释型语言执行效率低的问题，同时保留解释型语言可移植的特点。由于字节码文件不面向一种特定的操作系统，因此，只有有虚拟机，Java程序无需重新编译就可以在不同操作系统的计算机上运行。</p><p>Clojure（Lisp 语言的一种方言）、Groovy、Scala 等语言都是运行在 Java 虚拟机之上。.class文件是不同语言与JVM之间的桥梁，同时也是支持Java跨平台的重要原因。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/bg/desktop类文件结构概览.png" alt="不同语言编译成class文件" title="">                </div>                <div class="image-caption">不同语言编译成class文件</div>            </figure><h1 id="文件结构"><a href="#文件结构" class="headerlink" title="文件结构"></a>文件结构</h1><p>根据Java虚拟机规范，class文件通过<code>ClassFile</code>定义，结构如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">ClassFile &#123;</span><br><span class="line">    u4             magic; <span class="comment">//Class 文件的标志</span></span><br><span class="line">    u2             minor_version;<span class="comment">//Class 的小版本号</span></span><br><span class="line">    u2             major_version;<span class="comment">//Class 的大版本号</span></span><br><span class="line">    u2             constant_pool_count;<span class="comment">//常量池的数量</span></span><br><span class="line">    cp_info        constant_pool[constant_pool_count-<span class="number">1</span>];<span class="comment">//常量池</span></span><br><span class="line">    u2             access_flags;<span class="comment">//Class 的访问标记</span></span><br><span class="line">    u2             this_class;<span class="comment">//当前类</span></span><br><span class="line">    u2             super_class;<span class="comment">//父类</span></span><br><span class="line">    u2             interfaces_count;<span class="comment">//接口</span></span><br><span class="line">    u2             interfaces[interfaces_count];<span class="comment">//一个类可以实现多个接口</span></span><br><span class="line">    u2             fields_count;<span class="comment">//Class 文件的字段属性</span></span><br><span class="line">    field_info     fields[fields_count];<span class="comment">//一个类会可以有多个字段</span></span><br><span class="line">    u2             methods_count;<span class="comment">//Class 文件的方法数量</span></span><br><span class="line">    method_info    methods[methods_count];<span class="comment">//一个类可以有个多个方法</span></span><br><span class="line">    u2             attributes_count;<span class="comment">//此类的属性表中的属性数</span></span><br><span class="line">    attribute_info attributes[attributes_count];<span class="comment">//属性表集合</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/java-guide-blog/16d5ec47609818fc.jpeg" alt="Class文件结构" style="zoom: 50%;" /><h2 id="魔数-Magic-Number"><a href="#魔数-Magic-Number" class="headerlink" title="魔数(Magic Number)"></a>魔数(Magic Number)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">u4             magic; <span class="comment">//Class 文件的标志</span></span><br></pre></td></tr></table></figure><p>每个class文件的前4个字节成为魔数(Magic Number),它的唯一作用是<strong>确定这个文件是否为一个能被虚拟机接收的class文件。</strong></p><h2 id="Class文件版本号-Minor-amp-Major-Version"><a href="#Class文件版本号-Minor-amp-Major-Version" class="headerlink" title="Class文件版本号(Minor&amp;Major Version)"></a>Class文件版本号(Minor&amp;Major Version)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">u2             minor_version;<span class="comment">//Class 的小版本号</span></span><br><span class="line">u2             major_version;<span class="comment">//Class 的大版本号</span></span><br></pre></td></tr></table></figure><p>紧接着魔数的四个字节存储的是 Class 文件的版本号：第 5 和第 6 位是<strong>次版本号</strong>，第 7 和第 8 位是<strong>主版本号</strong>。</p><p>每当 Java 发布大版本（比如 Java 8，Java9）的时候，主版本号都会加 1。你可以使用 <code>javap -v</code> 命令来快速查看 Class 文件的版本号信息。</p><h2 id="常量池-Constant-Pool"><a href="#常量池-Constant-Pool" class="headerlink" title="常量池(Constant Pool)"></a>常量池(Constant Pool)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">u2             constant_pool_count;<span class="comment">//常量池的数量</span></span><br><span class="line">cp_info        constant_pool[constant_pool_count-<span class="number">1</span>];<span class="comment">//常量池</span></span><br></pre></td></tr></table></figure><p>紧接着主次版本号之后的是常量池，常量池的数量是 <code>constant_pool_count-1</code>（<strong>常量池计数器是从 1 开始计数的，将第 0 项常量空出来是有特殊考虑的，索引值为 0 代表“不引用任何一个常量池项”</strong>）。</p><p>常量池主要存放两大常量：字面量和符号引用。字面量比较接近于 Java 语言层面的的常量概念，如文本字符串、声明为 final 的常量值等。而符号引用则属于编译原理方面的概念。包括下面三类常量：</p><ul><li>类和接口的全限定名</li><li>字段的名称和描述符</li><li>方法的名称和描述符</li></ul><p>常量池中每一项常量都是一个表，这 14 种表有一个共同的特点：<strong>开始的第一位是一个 u1 类型的标志位 -tag 来标识常量的类型，代表当前这个常量属于哪种常量类型．</strong></p><table><thead><tr><th>类型</th><th>标志（tag）</th><th>描述</th></tr></thead><tbody><tr><td>CONSTANT_utf8_info</td><td>1</td><td>UTF-8 编码的字符串</td></tr><tr><td>CONSTANT_Integer_info</td><td>3</td><td>整形字面量</td></tr><tr><td>CONSTANT_Float_info</td><td>4</td><td>浮点型字面量</td></tr><tr><td>CONSTANT_Long_info</td><td>５</td><td>长整型字面量</td></tr><tr><td>CONSTANT_Double_info</td><td>６</td><td>双精度浮点型字面量</td></tr><tr><td>CONSTANT_Class_info</td><td>７</td><td>类或接口的符号引用</td></tr><tr><td>CONSTANT_String_info</td><td>８</td><td>字符串类型字面量</td></tr><tr><td>CONSTANT_Fieldref_info</td><td>９</td><td>字段的符号引用</td></tr><tr><td>CONSTANT_Methodref_info</td><td>10</td><td>类中方法的符号引用</td></tr><tr><td>CONSTANT_InterfaceMethodref_info</td><td>11</td><td>接口中方法的符号引用</td></tr><tr><td>CONSTANT_NameAndType_info</td><td>12</td><td>字段或方法的符号引用</td></tr><tr><td>CONSTANT_MothodType_info</td><td>16</td><td>标志方法类型</td></tr><tr><td>CONSTANT_MethodHandle_info</td><td>15</td><td>表示方法句柄</td></tr><tr><td>CONSTANT_InvokeDynamic_info</td><td>18</td><td>表示一个动态方法调用点</td></tr></tbody></table><h2 id="访问标志-Access-Flags"><a href="#访问标志-Access-Flags" class="headerlink" title="访问标志(Access Flags)"></a>访问标志(Access Flags)</h2><p>在常量池结束之后，紧接着的两个字节代表访问标志，这个标志用于识别一些类或者接口层次的访问信息，包括：这个 Class 是类还是接口，是否为 <code>public</code> 或者 <code>abstract</code> 类型，如果是类的话是否声明为 <code>final</code> 等等。</p><p>类访问和属性修饰符:</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-6/%E8%AE%BF%E9%97%AE%E6%A0%87%E5%BF%97.png" alt="类访问和属性修饰符" title="">                </div>                <div class="image-caption">类访问和属性修饰符</div>            </figure><h2 id="当前类-This-Class-、父类-Super-Class-、接口-Interfaces-索引集合"><a href="#当前类-This-Class-、父类-Super-Class-、接口-Interfaces-索引集合" class="headerlink" title="当前类(This Class)、父类(Super Class)、接口(Interfaces)索引集合"></a>当前类(This Class)、父类(Super Class)、接口(Interfaces)索引集合</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">u2             this_class;<span class="comment">//当前类</span></span><br><span class="line">u2             super_class;<span class="comment">//父类</span></span><br><span class="line">u2             interfaces_count;<span class="comment">//接口</span></span><br><span class="line">u2             interfaces[interfaces_count];<span class="comment">//一个类可以实现多个接口</span></span><br></pre></td></tr></table></figure><p>类索引用于确定这个类的全限定名，父类索引用于确定这个类的父类的全限定名，由于 Java 语言的单继承，所以父类索引只有一个，除了 <code>java.lang.Object</code> 之外，所有的 java 类都有父类，因此除了 <code>java.lang.Object</code> 外，所有 Java 类的父类索引都不为 0。</p><p>接口索引集合用来描述这个类实现了那些接口，这些被实现的接口将按 <code>implements</code> (如果这个类本身是接口的话则是<code>extends</code>) 后的接口顺序从左到右排列在接口索引集合中。</p><h2 id="字段表集合-Fields"><a href="#字段表集合-Fields" class="headerlink" title="字段表集合(Fields)"></a>字段表集合(Fields)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">u2             fields_count;<span class="comment">//Class 文件的字段的个数</span></span><br><span class="line">field_info     fields[fields_count];<span class="comment">//一个类会可以有个字段</span></span><br></pre></td></tr></table></figure><p>字段表（field info）用于<strong>描述接口或类中声明的变量</strong>。字段<strong>包括类级变量以及实例变量</strong>，但<strong>不包括在方法内部声明的局部变量。</strong></p><h3 id="field-info结构"><a href="#field-info结构" class="headerlink" title="field info结构"></a>field info结构</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-6/%E5%AD%97%E6%AE%B5%E8%A1%A8%E7%9A%84%E7%BB%93%E6%9E%84.png" alt="字段表的结构" title="">                </div>                <div class="image-caption">字段表的结构</div>            </figure><ul><li><strong>access_flags:</strong> 字段的作用域（<code>public</code> ,<code>private</code>,<code>protected</code>修饰符），是实例变量还是类变量（<code>static</code>修饰符）,可否被序列化（transient 修饰符）,可变性（final）,可见性（volatile 修饰符，是否强制从主内存读写）。</li><li><strong>name_index:</strong> 对常量池的引用，表示的字段的名称；</li><li><strong>descriptor_index:</strong> 对常量池的引用，表示字段和方法的描述符；</li><li><strong>attributes_count:</strong> 一个字段还会拥有一些额外的属性，attributes_count 存放属性的个数；</li><li><strong>attributes[attributes_count]:</strong> 存放具体属性具体内容。</li></ul><p>上述这些信息中，各个修饰符都是布尔值，要么有某个修饰符，要么没有，很适合使用标志位来表示。而字段叫什么名字、字段被定义为什么数据类型这些都是无法固定的，只能引用常量池中常量来描述。</p><h3 id="字段表access-flag的取值"><a href="#字段表access-flag的取值" class="headerlink" title="字段表access_flag的取值"></a>字段表access_flag的取值</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/JVM/image-20201031084342859.png" alt="字段的 access_flag 的取值" title="">                </div>                <div class="image-caption">字段的 access_flag 的取值</div>            </figure><h2 id="方法表集合-Methods"><a href="#方法表集合-Methods" class="headerlink" title="方法表集合(Methods)"></a>方法表集合(Methods)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">u2             methods_count;<span class="comment">//Class 文件的方法的数量</span></span><br><span class="line">method_info    methods[methods_count];<span class="comment">//一个类可以有个多个方法</span></span><br></pre></td></tr></table></figure><p>methods_count 表示方法的数量，而 method_info 表示方法表。</p><p>Class 文件存储格式中<strong>对方法的描述与对字段的描述几乎采用了完全一致的方式。</strong>方法表的结构如同字段表一样，依次包括了访问标志、名称索引、描述符索引、属性表集合几项。</p><h3 id="method-info结构"><a href="#method-info结构" class="headerlink" title="method_info结构"></a>method_info结构</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-6/%E6%96%B9%E6%B3%95%E8%A1%A8%E7%9A%84%E7%BB%93%E6%9E%84.png" alt="方法表的结构" title="">                </div>                <div class="image-caption">方法表的结构</div>            </figure><h3 id="方法表access-flag的取值"><a href="#方法表access-flag的取值" class="headerlink" title="方法表access_flag的取值"></a>方法表access_flag的取值</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/JVM/image-20201031084248965.png" alt="方法表的 access_flag 取值" title="">                </div>                <div class="image-caption">方法表的 access_flag 取值</div>            </figure><p>注意：因为<code>volatile</code>修饰符和<code>transient</code>修饰符不可以修饰方法，所以方法表的访问标志中没有这两个对应的标志，但是增加了<code>synchronized</code>、<code>native</code>、<code>abstract</code>等关键字修饰方法，所以也就多了这些关键字对应的标志。</p><h2 id="属性表集合-Attributes"><a href="#属性表集合-Attributes" class="headerlink" title="属性表集合(Attributes)"></a>属性表集合(Attributes)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">u2             attributes_count;<span class="comment">//此类的属性表中的属性数</span></span><br><span class="line">attribute_info attributes[attributes_count];<span class="comment">//属性表集合</span></span><br></pre></td></tr></table></figure><p>在 Class 文件，字段表，方法表中都可以携带自己的属性表集合，以用于描述某些场景专有的信息。与 Class 文件中其它的数据项目要求的顺序、长度和内容不同，属性表集合的限制稍微宽松一些，不再要求各个属性表具有严格的顺序，并且只要不与已有的属性名重复，任何人实现的编译器都可以向属性表中写 入自己定义的属性信息，Java 虚拟机运行时会忽略掉它不认识的属性。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://snailclimb.gitee.io/javaguide/#/docs/java/jvm/类文件结构?id=类文件结构" target="_blank" rel="noopener">类文件结构</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;p&gt;在Java中，能够被JVM理解的代码叫做字节码文件也就是.class文件。Java通过字节码的方式，在一定程度上解决了传统解释型语言执行效率
      
    
    </summary>
    
    
      <category term="Java" scheme="https://xdmqp.github.io/categories/Java/"/>
    
    
      <category term="Java" scheme="https://xdmqp.github.io/tags/Java/"/>
    
      <category term="JVM" scheme="https://xdmqp.github.io/tags/JVM/"/>
    
      <category term="字节码文件" scheme="https://xdmqp.github.io/tags/%E5%AD%97%E8%8A%82%E7%A0%81%E6%96%87%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>Java内存泄漏与内存溢出</title>
    <link href="https://xdmqp.github.io/2021/06/30/%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E4%B8%8E%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA/"/>
    <id>https://xdmqp.github.io/2021/06/30/%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E4%B8%8E%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA/</id>
    <published>2021-06-29T16:00:00.000Z</published>
    <updated>2021-07-06T08:32:12.710Z</updated>
    
    <content type="html"><![CDATA[<h2 id="内存泄漏与内存溢出"><a href="#内存泄漏与内存溢出" class="headerlink" title="内存泄漏与内存溢出"></a>内存泄漏与内存溢出</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>内存泄漏：申请使用完的内存无法释放，导致虚拟机不能再次使用该内存，此时就会产生内存泄露了，因为申请者不用了，而又不能被虚拟机分配给别人用。</p><p>内存溢出：申请的内存超出了JVM能提供的内存大小，此时称之为溢出。</p><p><strong>内存泄漏是内存溢出的一种诱因，但不是唯一因素。</strong></p><h3 id="内存泄漏常见原因"><a href="#内存泄漏常见原因" class="headerlink" title="内存泄漏常见原因"></a>内存泄漏常见原因</h3><h4 id="1-静态集合类"><a href="#1-静态集合类" class="headerlink" title="1.静态集合类"></a>1.静态集合类</h4><p>如HashMap、LinkedList等等。如果这些容器为静态的，那么它们的生命周期与程序一致，则容器中的对象在程序结束之前将不能被释放，从而造成内存泄漏。简单而言，<strong>长生命周期的对象持有短生命周期对象的引用</strong>，<strong>尽管短生命周期的对象不再使用，但是因为长生命周期对象持有它的引用而导致不能被回收。</strong></p><h4 id="2-各种连接，如数据库连接、网络连接和IO连接等"><a href="#2-各种连接，如数据库连接、网络连接和IO连接等" class="headerlink" title="2.各种连接，如数据库连接、网络连接和IO连接等"></a><strong>2.各种连接，如数据库连接、网络连接和IO连接等</strong></h4><p>在对数据库进行操作的过程中，首先需要建立与数据库的连接，当不再使用时，<strong>需要调用close方法来释放与数据库的连接</strong>。只有连接被关闭后，垃圾回收器才会回收对应的对象。否则，如果在访问数据库的过程中，对Connection、Statement或ResultSet<strong>不显性地关闭，将会造成大量的对象无法被回收，从而引起内存泄漏</strong>。</p><h4 id="3-变量不合理的作用域"><a href="#3-变量不合理的作用域" class="headerlink" title="3.变量不合理的作用域"></a>3.变量不合理的作用域</h4><p><strong>一个变量的定义的作用范围大于其使用范围</strong>，很有可能会造成内存泄漏。另一方面，<strong>如果没有及时地把对象设置为null</strong>，很有可能导致内存泄漏的发生。</p><h4 id="4-内部类持有外部类"><a href="#4-内部类持有外部类" class="headerlink" title="4.内部类持有外部类"></a>4.内部类持有外部类</h4><p>如果一个外部类的实例对象的方法返回了一个内部类的实例对象，这个内部类对象被长期引用了，即使那个外部类实例对象不再被使用，但由于内部类持有外部类的实例对象，这个外部类对象将不会被垃圾回收，这也会造成内存泄露。</p><h4 id="5-改变哈希值"><a href="#5-改变哈希值" class="headerlink" title="5.改变哈希值"></a>5.改变哈希值</h4><p>当一个对象被存储进HashSet集合中以后，就不能修改这个对象中的那些参与计算哈希值的字段了，否则，对象修改后的哈希值与最初存储进HashSet集合中时的哈希值就不同了，在这种情况下，即使在contains方法使用该对象的当前引用作为的参数去HashSet集合中检索对象，也将返回找不到对象的结果，这也会导致无法从HashSet集合中单独删除当前对象，造成内存泄露</p><h4 id="6-栈中连续的POP操作"><a href="#6-栈中连续的POP操作" class="headerlink" title="6.栈中连续的POP操作"></a>6.栈中连续的POP操作</h4><p>当进行大量的pop操作时，由于引用未进行置空，gc是不会释放的。如果栈先增长，在收缩，那么从栈中弹出的对象将不会被当作垃圾回收，即使程序不再使用栈中的这些对象，他们也不会回收，因为栈中仍然保存这对象的引用，俗称过期引用，这个内存泄露很隐蔽。</p><h4 id="7-缓存泄漏"><a href="#7-缓存泄漏" class="headerlink" title="7.缓存泄漏"></a>7.缓存泄漏</h4><p>内存泄漏的另一个常见来源是缓存，一旦你把对象引用放入到缓存中，他就很容易遗忘，对于这个问题，可以使用WeakHashMap代表缓存，此种Map的特点是，当除了自身有对key的引用外，此key没有其他引用那么此map会自动丢弃此值。</p><h4 id="8-监听器和回调"><a href="#8-监听器和回调" class="headerlink" title="8.监听器和回调"></a>8.监听器和回调</h4><p>内存泄漏第三个常见来源是监听器和其他回调，如果客户端在你实现的API中注册回调，却没有显示的取消，那么就会积聚。需要确保回调立即被当作垃圾回收的最佳方法是只保存他的若引用，例如将他们保存成为WeakHashMap中的键。</p><h3 id="内存溢出三种情况"><a href="#内存溢出三种情况" class="headerlink" title="内存溢出三种情况"></a>内存溢出三种情况</h3><h4 id="1-堆内存溢出"><a href="#1-堆内存溢出" class="headerlink" title="1.堆内存溢出"></a>1.堆内存溢出</h4><p>java.lang.OutOfMemoryError: Java heap space ——&gt;java堆内存溢出，此种情况最常见，一般<strong>由于内存泄露或者堆的大小设置不当引起</strong>。对于内存泄露，需要通过内存监控软件查找程序中的泄露代码，而<strong>堆大小可以通过虚拟机参数-Xms,-Xmx等修改</strong>。</p><h4 id="2-元空间溢出"><a href="#2-元空间溢出" class="headerlink" title="2.元空间溢出"></a>2.元空间溢出</h4><p>java.lang.OutOfMemoryError: PermGen space 或 java.lang.OutOfMemoryError：MetaSpace ——&gt;java方法区，（java8 元空间）溢出了，<strong>一般出现于程序加载的类过多，或者采用反射、cglib等动态代理生成类技术</strong>的情况，因为<strong>上述情况会产生大量的Class信息存储于方法区</strong>。此种情况可以通过更改方法区的大小来解决，使用类似-XX:PermSize=64m -XX:MaxPermSize=256m的形式修改。另外，<strong>过多的常量尤其是字符串也会导致方法区中的运行时常量池溢出。</strong></p><h4 id="3-栈溢出"><a href="#3-栈溢出" class="headerlink" title="3.栈溢出"></a>3.栈溢出</h4><ul><li><strong>虚拟机栈容量不允许动态扩展</strong>：如果线程请求的栈深度大于虚拟机所允许的最大深度，将抛出StackOverflowError，一般是<strong>由于程序中存在死循环或者大量递归调用</strong>造成的</li><li><strong>虚拟机栈容量可以动态扩展</strong>：当不断创建线程，如果虚拟机在扩展栈时无法申请到足够的内存空间，则抛出OutOfMemoryError　</li></ul><p>可以通过虚拟机参数-Xss来设置栈的大小。</p><h4 id="排查手段"><a href="#排查手段" class="headerlink" title="排查手段"></a>排查手段</h4><p>先通过内存映像工具对Dump出来的堆转储快照进行分析，<strong>重点是确认内存中的对象是否是必要的，也就是要先分清楚到底是出现了内存泄漏还是内存溢出。</strong></p><ul><li>如果是内存泄漏，可进一步通过工具<strong>查看泄漏对象到GC Roots的引用链</strong>。这样就能够找到泄漏的对象是<strong>通过怎么样的路径与GC Roots相关联的导致垃圾回收机制无法将其回收</strong>。掌握了泄漏对象的类信息和GC Roots引用链的信息，就可以比较准确地定位泄漏代码的位置。</li><li>如果不存在泄漏，那么就是内存中的对象确实必须存活着，那么此时就需要通过虚拟机的堆参数（ -Xms初始堆空间默认大小和-Xmx最大堆空间默认大小）来适当调大参数；<strong>从代码上检查是否存在某些对象存活时间过长(static修饰)、持有时间过长</strong>的情况，尝试减少运行时内存的消耗。</li></ul><h3 id="如何避免内存泄漏和溢出"><a href="#如何避免内存泄漏和溢出" class="headerlink" title="如何避免内存泄漏和溢出"></a>如何避免内存泄漏和溢出</h3><p>尽早释放无用对象的引用</p><p>使用字符串处理，避免使用String，应大量使用StringBuffer，每一个String对象都得独立占用内存一块区域</p><p>尽量少用静态变量，因为静态变量存放在永久代（方法区），永久代基本不参与垃圾回收</p><p>避免在循环中创建对象</p><p>开启大型文件或从数据库一次拿了太多的数据很容易造成内存溢出，所以在这些地方要大概计算一下数据量的最大值是多少，并且设定所需最小及最大的内存空间值。</p><blockquote><p>内存溢出、内存泄漏和栈溢出：<a href="https://www.cnblogs.com/haimishasha/p/11329510.html" target="_blank" rel="noopener">https://www.cnblogs.com/haimishasha/p/11329510.html</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;内存泄漏与内存溢出&quot;&gt;&lt;a href=&quot;#内存泄漏与内存溢出&quot; class=&quot;headerlink&quot; title=&quot;内存泄漏与内存溢出&quot;&gt;&lt;/a&gt;内存泄漏与内存溢出&lt;/h2&gt;&lt;h3 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; 
      
    
    </summary>
    
    
      <category term="Java" scheme="https://xdmqp.github.io/categories/Java/"/>
    
    
      <category term="Java" scheme="https://xdmqp.github.io/tags/Java/"/>
    
      <category term="内存泄漏" scheme="https://xdmqp.github.io/tags/%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F/"/>
    
      <category term="内存溢出" scheme="https://xdmqp.github.io/tags/%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA/"/>
    
  </entry>
  
  <entry>
    <title>Java静态代理和动态代理</title>
    <link href="https://xdmqp.github.io/2021/06/19/Java%E9%9D%99%E6%80%81%E4%BB%A3%E7%90%86%E5%92%8C%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/"/>
    <id>https://xdmqp.github.io/2021/06/19/Java%E9%9D%99%E6%80%81%E4%BB%A3%E7%90%86%E5%92%8C%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/</id>
    <published>2021-06-18T16:00:00.000Z</published>
    <updated>2021-07-10T14:07:58.397Z</updated>
    
    <content type="html"><![CDATA[<h3 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h3><p>代理模式是常用的java设计模式，他的特征是代理类与委托类有同样的接口，代理类主要负责为委托类预处理消息、过滤消息、把消息转发给委托类，以及事后处理消息等。代理类与委托类之间通常会存在关联关系，一个代理类的对象与一个委托类的对象关联，代理类的对象本身并不真正实现服务，而是通过调用委托类的对象的相关方法，来提供特定的服务。简单的说就是，我们在<strong>访问实际对象时，是通过代理对象来访问的，代理模式就是在访问实际对象时引入一定程度的间接性，因为这种间接性，可以附加多种用途</strong>。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://images2015.cnblogs.com/blog/1085268/201704/1085268-20170409105440082-1652546649.jpg" alt="img" title="">                </div>                <div class="image-caption">img</div>            </figure><h3 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h3><p>由程序员创建或特定工具自动生成源代码，也就是在<strong>编译时</strong>就已经将接口，被代理类，代理类等确定下来。在程序运行之前，代理类的.class文件就已经生成。</p><p><strong>缺点：</strong></p><p>因为Proxy需要和RealSubject实现同样的接口，一旦接口增加了方法，Proxy和RealSubject都要进行维护。</p><h3 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>代理类在程序<strong>运行时</strong>创建的代理方式被称为动态代理。在静态代理中，代理类是自己定义好的，在程序运行之前就已经编译完成。然而动态代理，代理类并不是在Java代码中定义的，而是在运行时根据我们在Java代码中的“指示”动态生成的。相比于静态代理， 动态代理的<strong>优势在于可以很方便的对代理类的函数进行统一的处理，而不用修改每个代理类中的方法。</strong></p><h4 id="Jdk实现"><a href="#Jdk实现" class="headerlink" title="Jdk实现"></a>Jdk实现</h4><p>在java的java.lang.reflect包下提供了一个Proxy类和一个InvocationHandler接口，通过这个类和这个接口可以生成JDK动态代理类和动态代理对象。</p><p><strong>用户管理接口：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//用户管理接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserManager</span> </span>&#123;</span><br><span class="line">    <span class="comment">//新增用户抽象方法</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addUser</span><span class="params">(String userName,String password)</span></span>;</span><br><span class="line">    <span class="comment">//删除用户抽象方法</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">delUser</span><span class="params">(String userName)</span></span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>用户管理接口实现类：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//用户管理实现类,实现用户管理接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserManagerImpl</span> <span class="keyword">implements</span> <span class="title">UserManager</span></span>&#123;</span><br><span class="line">    <span class="comment">//重写新增用户方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addUser</span><span class="params">(String userName, String password)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"调用了新增的方法！"</span>);</span><br><span class="line">        System.out.println(<span class="string">"传入参数为 userName: "</span>+userName+<span class="string">" password: "</span>+password);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//重写删除用户方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delUser</span><span class="params">(String userName)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"调用了删除的方法！"</span>);</span><br><span class="line">        System.out.println(<span class="string">"传入参数为 userName: "</span>+userName);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> UserManager;</span><br><span class="line"><span class="keyword">import</span> UserManagerImpl;</span><br><span class="line"><span class="comment">//JDK动态代理实现InvocationHandler接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JdkProxy</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Object target ;<span class="comment">//需要代理的目标对象</span></span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"JDK动态代理，监听开始！"</span>);</span><br><span class="line">        Object result = method.invoke(target, args);</span><br><span class="line">        System.out.println(<span class="string">"JDK动态代理，监听结束！"</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//定义获取代理对象方法</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Object <span class="title">getJDKProxy</span><span class="params">(Object targetObject)</span></span>&#123;</span><br><span class="line">        <span class="comment">//为目标对象target赋值</span></span><br><span class="line">        <span class="keyword">this</span>.target = targetObject;</span><br><span class="line">        <span class="comment">//JDK动态代理只能针对实现了接口的类进行代理，newProxyInstance 函数所需参数就可看出</span></span><br><span class="line">        <span class="keyword">return</span> Proxy.newProxyInstance(targetObject.getClass().getClassLoader(), targetObject.getClass().getInterfaces(), <span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        JdkProxy jdkProxy = <span class="keyword">new</span> JdkProxy();<span class="comment">//实例化JDKProxy对象</span></span><br><span class="line">        UserManager user = (UserManager) jdkProxy.getJDKProxy(<span class="keyword">new</span> UserManagerImpl());<span class="comment">//获取代理对象</span></span><br><span class="line">        user.addUser(<span class="string">"admin"</span>, <span class="string">"123123"</span>);<span class="comment">//执行新增方法</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Cglib实现"><a href="#Cglib实现" class="headerlink" title="Cglib实现"></a><strong>Cglib实现</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> com.lf.shejimoshi.proxy.entity.UserManager;</span><br><span class="line"><span class="keyword">import</span> com.lf.shejimoshi.proxy.entity.UserManagerImpl;</span><br><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.Enhancer;</span><br><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.MethodInterceptor;</span><br><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.MethodProxy;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Cglib动态代理，实现MethodInterceptor接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CglibProxy</span> <span class="keyword">implements</span> <span class="title">MethodInterceptor</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Object target;<span class="comment">//需要代理的目标对象</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//重写拦截方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object obj, Method method, Object[] arr, MethodProxy proxy)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Cglib动态代理，监听开始！"</span>);</span><br><span class="line">        Object invoke = method.invoke(target, arr);<span class="comment">//方法执行，参数：target 目标对象 arr参数数组</span></span><br><span class="line">        System.out.println(<span class="string">"Cglib动态代理，监听结束！"</span>);</span><br><span class="line">        <span class="keyword">return</span> invoke;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//定义获取代理对象方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getCglibProxy</span><span class="params">(Object objectTarget)</span></span>&#123;</span><br><span class="line">        <span class="comment">//为目标对象target赋值</span></span><br><span class="line">        <span class="keyword">this</span>.target = objectTarget;</span><br><span class="line">        Enhancer enhancer = <span class="keyword">new</span> Enhancer();</span><br><span class="line">        <span class="comment">//设置父类,因为Cglib是针对指定的类生成一个子类，所以需要指定父类</span></span><br><span class="line">        enhancer.setSuperclass(objectTarget.getClass());</span><br><span class="line">        enhancer.setCallback(<span class="keyword">this</span>);<span class="comment">// 设置回调 </span></span><br><span class="line">        Object result = enhancer.create();<span class="comment">//创建并返回代理对象</span></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        CglibProxy cglib = <span class="keyword">new</span> CglibProxy();<span class="comment">//实例化CglibProxy对象</span></span><br><span class="line">        UserManager user =  (UserManager) cglib.getCglibProxy(<span class="keyword">new</span> UserManagerImpl());<span class="comment">//获取代理对象</span></span><br><span class="line">        user.delUser(<span class="string">"admin"</span>);<span class="comment">//执行删除方法</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>Jdk通过Proxy类和实现InvocationHandler实现动态代理。</p><p>Cglib通过构建目标对象子类的方式实现代理。</p><p><strong>静态代理和JDK动态代理都要求目标对象是实现一个接口的目标对象,如果目标对象只是一个单独的对象,并没有实现任何的接口，则只能使用Cglib代理。</strong></p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><blockquote><p><a href="https://www.cnblogs.com/leifei/p/8263448.html" target="_blank" rel="noopener">Spring的两种动态代理：Jdk和Cglib 的区别和实现</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;代理模式&quot;&gt;&lt;a href=&quot;#代理模式&quot; class=&quot;headerlink&quot; title=&quot;代理模式&quot;&gt;&lt;/a&gt;代理模式&lt;/h3&gt;&lt;p&gt;代理模式是常用的java设计模式，他的特征是代理类与委托类有同样的接口，代理类主要负责为委托类预处理消息、过滤消息、把消息转
      
    
    </summary>
    
    
      <category term="Java" scheme="https://xdmqp.github.io/categories/Java/"/>
    
    
      <category term="Java" scheme="https://xdmqp.github.io/tags/Java/"/>
    
      <category term="代理模式" scheme="https://xdmqp.github.io/tags/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Java虚拟机</title>
    <link href="https://xdmqp.github.io/2021/03/14/Java%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    <id>https://xdmqp.github.io/2021/03/14/Java%E8%99%9A%E6%8B%9F%E6%9C%BA/</id>
    <published>2021-03-13T16:00:00.000Z</published>
    <updated>2021-07-07T02:56:49.241Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-运行时数据区域"><a href="#1-运行时数据区域" class="headerlink" title="1.   运行时数据区域"></a>1.   运行时数据区域</h1><h2 id="1-1-程序计数器"><a href="#1-1-程序计数器" class="headerlink" title="1.1.    程序计数器"></a>1.1.    程序计数器</h2><p>记录<strong>正在执行的虚拟机字节码指令的地址</strong>（如果正在执行的是本地方法则为空）。字节码解释器工作时<strong>通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等功能都需要依赖这个计数器来完成。</strong><br> 另外，为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各线程之间计数器互不影响，独立存储，我们称这类内存区域为“线程私有”的内存。<br> 程序计数器的两个作用：<br> 字节码解释器通过改变程序计数器来依次读取指令，从而<strong>实现代码的流程控制</strong>，如：顺序执行、选择、循环、异常处理。<br> 在多线程的情况下，<strong>程序计数器用于记录当前线程执行的位置</strong>，从而当线程被切换回来的时候能够知道该线程上次运行到哪儿了。</p><h2 id="1-2-Java虚拟机栈"><a href="#1-2-Java虚拟机栈" class="headerlink" title="1.2.    Java虚拟机栈"></a>1.2.    Java虚拟机栈</h2><p>每个 Java 方法在执行的同时会创建一个栈帧用于存储<strong>局部变量表（8种基本类型、对象的引用地址）、操作数栈、动态链接、方法出口</strong>等信息。从方法调用直至执行完成的过程，对应着一个栈帧在 Java 虚拟机栈中入栈和出栈的过程。<br> 可以通过 -Xss 这个虚拟机参数来指定每个线程的 Java 虚拟机栈内存大小，在 JDK 1.4 中默认为 256K，而在 JDK 1.5+ 默认为 1M<br> 操作Java虚拟机栈有可能会抛出以下异常：<br> <strong>当线程请求的栈深度超过最大值</strong>，会抛出 StackOverflowError 异常；<br> <strong>栈进行动态扩展时如果无法申请到足够内存</strong>，会抛出 OutOfMemoryError 异常。</p><h2 id="1-3-本地方法栈"><a href="#1-3-本地方法栈" class="headerlink" title="1.3.    本地方法栈"></a>1.3.    本地方法栈</h2><p>本地方法栈与 Java 虚拟机栈类似，<strong>它们之间的区别只不过是本地方法栈为本地方法服务</strong>。在 HotSpot 虚拟机中和 Java 虚拟机栈合二为一。<br> 本地方法被执行的时候，在本地方法栈也会创建一个栈帧，用于存放该本地方法的局部变量表、操作数栈、动态链接、出口信息。<br> 方法执行完毕后相应的栈帧也会出栈并释放内存空间，也会出现 StackOverFlowError 和 OutOfMemoryError 两种错误。</p><h2 id="1-4-堆"><a href="#1-4-堆" class="headerlink" title="1.4.    堆"></a>1.4.    堆</h2><p>用于<strong>存放对象实例，所有对象都在这里分配内存</strong>，是垃圾收集的主要区域（”GC 堆”）。</p><p>现代的垃圾收集器基本都是采用分代收集算法，其主要的思想是针对不同类型的对象采取不同的垃圾回收算法。可以将堆分成两块：新生代和老年代。</p><p> 在JDK7及以前，堆内存被分为三部分：新生代、老生代、永久代。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/xdmqp/myPic/main/img/JVM%E5%A0%86%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84-JDK7.png" alt="JVM堆内存结构-JDK7" title="">                </div>                <div class="image-caption">JVM堆内存结构-JDK7</div>            </figure><p>JDK8版本之后方法区被彻底移除，由元空间代替，元空间使用的是直接内存。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/xdmqp/myPic/main/img/JVM%E5%A0%86%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84-jdk8.png" alt="JVM堆内存结构-JDK8" title="">                </div>                <div class="image-caption">JVM堆内存结构-JDK8</div>            </figure><p><strong>图中的 Eden 区、两个 Survivor 区都属于新生代，中间一层属于老年代。</strong></p><p>大多数对象首先在Eden区进行分配，在进行一次垃圾回收后，如果对象仍然存活，则进入s0或者s1，并且对象的年龄还会加1，Eden区刚进入Survivor区后的初始年龄为1），当年龄增加到一定程度时，就会晋升到老年代中，默认为15岁。对象晋升到老年代的阈值可以通过<code>-XX:MaxTenuringThreshold</code> 来设置。</p><p>另外，<strong>Hotspot在遍历所有对象时，按照年龄从小到大对其所占用的大小进行累积，当累积的某个年龄大小超过了 survivor 区的一半时，取这个年龄和 MaxTenuringThreshold 中更小的一个值，作为新的晋升年龄阈值。</strong></p><ul><li>堆不需要连续内存，并且可以动态增加其内存，增加失败会抛出 OutOfMemoryError 异常。 可以通过 -Xms 和 -Xmx 这两个虚拟机参数来指定一个程序的堆内存大小，第一个参数设置初始值，第二个参数设置最大值。</li><li>当 JVM 花太多时间执行垃圾回收并且只能回收很少的堆空间时，会发生OutOfMemoryError错误。</li></ul><h2 id="1-5-方法区"><a href="#1-5-方法区" class="headerlink" title="1.5.    方法区"></a>1.5.    方法区</h2><p>用于存放<strong>已被加载的类信息、常量、静态变量、即时编译器编译后的代码</strong>等数据<br> 和堆一样不需要连续的内存，并且可以动态扩展，动态扩展失败一样会抛出 OutOfMemoryError 异常。<br> 对这块区域进行垃圾回收的主要目标是对常量池的回收和对类的卸载，但是一般比较难实现。</p><p> <strong>方法区是一个 JVM 规范，永久代与元空间都是其一种实现方式。</strong></p><p> HotSpot 虚拟机把它当成永久代来进行垃圾回收。但很难确定永久代的大小，因为它受到很多因素影响，并且每次 Full GC 之后永久代的大小都会改变，所以经常会抛出 OutOfMemoryError 异常。为了更容易管理方法区，从 JDK 1.8 开始，移除永久代，并把方法区移至元空间，它位于本地内存中，而不是虚拟机内存中。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://img-blog.csdnimg.cn/20210425134508117.png" alt="img" title="">                </div>                <div class="image-caption">img</div>            </figure><p>整个永久代有一个 JVM 本身设置的固定大小上限，无法进行调整，而元空间使用的是直接内存，受本机可用内存的限制，虽然元空间仍旧可能溢出，但是比原来出现的几率会更小。</p><p>可以使用 <code>-XX：MaxMetaspaceSize</code> 标志设置最大元空间大小，默认值为 unlimited，这意味着它只受系统内存的限制。<code>-XX：MetaspaceSize</code> 调整标志定义元空间的初始大小如果未指定此标志，则 Metaspace 将根据运行时的应用程序需求动态地重新调整大小。</p><h2 id="1-6-运行时常量池"><a href="#1-6-运行时常量池" class="headerlink" title="1.6.    运行时常量池"></a>1.6.    运行时常量池</h2><p>方法区的一部分。<br> Class 文件中的常量池（编译器生成的字面量和符号引用）会在类加载后被放入这个区域。<strong>字面量相当于Java语言层面常量的概念，如文本字符串，声明为final的常量值等，符号引用则属于编译原理方面的概念，包括了如下三种类型的常量：</strong></p><ol><li><p>类和接口的全限定名</p></li><li><p>字段名称和描述符</p></li><li><p>方法名称和描述符</p><p>除了在编译期生成的常量，还允许动态生成，例如 String 类的 intern()。</p></li></ol><p><strong>运行时常量池的变动：</strong></p><ul><li>JDK1.7 之前运行时常量池逻辑包含字符串常量池存放在方法区, 此时 hotspot 虚拟机对方法区的实现为永久代</li><li>JDK1.7 字符串常量池被从方法区拿到了堆中, 这里没有提到运行时常量池,也就是说字符串常量池被单独拿到堆,运行时常量池剩下的东西还在方法区, 也就是 hotspot 中的永久代 。</li><li>JDK1.8 hotspot 移除了永久代用元空间(Metaspace)取而代之, 这时候字符串常量池还在堆, 运行时常量池还在方法区, 只不过方法区的实现从永久代变成了元空间(Metaspace)</li></ul><h2 id="1-7-直接内存"><a href="#1-7-直接内存" class="headerlink" title="1.7.    直接内存"></a>1.7.    直接内存</h2><p><strong>直接内存并不是虚拟机运行时数据区的一部分，也不是虚拟机规范中定义的内存区域，但是这部分内存也被频繁地使用。而且也可能导致 OutOfMemoryError 错误出现。</strong></p><p>在 JDK 1.4 中新引入了 NIO 类，它可以使用 Native 函数库直接分配堆外内存，然后通过 Java 堆里的 DirectByteBuffer 对象作为这块内</p><p>存的引用进行操作。这样能在一些场景中显著提高性能，因为避免了在堆内存和堆外内存来回拷贝数据。</p><p>本机直接内存的分配不会受到 Java 堆的限制，但是，既然是内存就会受到本机总内存大小以及处理器寻址空间的限制。</p><h1 id="2-HotSpot虚拟机对象"><a href="#2-HotSpot虚拟机对象" class="headerlink" title="2.   HotSpot虚拟机对象"></a>2.   HotSpot虚拟机对象</h1><h2 id="2-1-对象的创建过程"><a href="#2-1-对象的创建过程" class="headerlink" title="2.1. 对象的创建过程"></a>2.1. 对象的创建过程</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/xdmqp/myPic/main/img/Java%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E7%9A%84%E8%BF%87%E7%A8%8B.png" alt="Java创建对象的过程" title="">                </div>                <div class="image-caption">Java创建对象的过程</div>            </figure><h3 id="2-1-1-类加载检查"><a href="#2-1-1-类加载检查" class="headerlink" title="2.1.1. 类加载检查"></a>2.1.1. 类加载检查</h3><p>虚拟机遇到new指令时，首先<strong>检查这个指令的参数能否在常量池定位到这个类的符号引用，并且检查这个符号引用代表的类是否已经被加载、解析和初始化过，如果没有，那必须先执行类的加载过程。</strong></p><h3 id="2-1-2-分配内存"><a href="#2-1-2-分配内存" class="headerlink" title="2.1.2. 分配内存"></a>2.1.2. 分配内存</h3><p>在<strong>类加载检查</strong>通过后，接下来虚拟机将为新生对象<strong>分配内存</strong>。对象所需的内存大小在类加载完成后便可确定，为对象分配空间的任务等同于把一块确定大小的内存从 Java 堆中划分出来。<strong>分配方式</strong>有 <strong>“指针碰撞”</strong> 和 <strong>“空闲列表”</strong> 两种，<strong>选择哪种分配方式由 Java 堆是否规整决定，而 Java 堆是否规整又由所采用的垃圾收集器是“标记-清除”，还是“标记-整理”</strong>。</p><ul><li>指针碰撞：适用于堆内存规整的情况，将用过的内存全部整合到一边，没有用过的内存放在另一边，并维护一个分界值指针，每次分配内存时，从分界值指针向着没用过内存的方向移动对象内存大小位置。</li><li>空闲列表：适用于堆内存不规整的情况，虚拟机维护一个列表，用来几乎哪些内存块是可用的，在分配时，找到一块足够大的内存分配给对象实例，最后更新列表。</li></ul><p>空闲列表：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/xdmqp/myPic/main/img/%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%96%B9%E5%BC%8F.png" alt="内存分配的两种方式" title="">                </div>                <div class="image-caption">内存分配的两种方式</div>            </figure><p><strong>内存分配的并发问题</strong></p><p>虚拟机通过两种方式来保证线程安全：</p><ul><li><strong>CAS+失败重试：</strong>CAS是乐观锁的一种实现方式。每次假设没有冲突去完成某项操作，如果因为冲突失败重试，直到成功为止。<strong>虚拟机通过这种方式保证更新操作的原子性。</strong></li><li><strong>TLAB（线程本地分配缓存区）</strong>：为每个线程预先在Eden区分配一块内存TLAB，每次为线程中的对象分配内存时，首先在TLAB分配，如果TLAB剩余内存不足，再采用CAS+失败重试的方式分配。</li></ul><h3 id="2-1-3-初始化零值"><a href="#2-1-3-初始化零值" class="headerlink" title="2.1.3. 初始化零值"></a>2.1.3. 初始化零值</h3><p>内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值（不包括对象头），<strong>这一步操作保证了对象的实例字段在 Java 代码中可以不赋初始值就直接使用，程序能访问到这些字段的数据类型所对应的零值。</strong></p><h3 id="2-1-4-设置对象头"><a href="#2-1-4-设置对象头" class="headerlink" title="2.1.4. 设置对象头"></a>2.1.4. 设置对象头</h3><p>初始化零值完成之后，<strong>虚拟机要对对象进行必要的设置</strong>，例如这个对象<strong>是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的 GC 分代年龄</strong>等信息。 <strong>这些信息存放在对象头中。</strong> 另外，根据虚拟机当前运行状态的不同，如是否启用偏向锁等，对象头会有不同的设置方式。</p><h3 id="2-1-5-执行init方法"><a href="#2-1-5-执行init方法" class="headerlink" title="2.1.5. 执行init方法"></a>2.1.5. 执行init方法</h3><p>在上面工作都完成之后，从虚拟机的视角来看，一个新的对象已经产生了，但从 Java 程序的视角来看，对象创建才刚开始，<code>&lt;init&gt;</code> 方法还没有执行，所有的字段都还为零。所以一般来说，执行 new 指令之后会接着执行 <code>&lt;init&gt;</code> 方法，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完全产生出来。</p><h2 id="2-2-对象内存布局"><a href="#2-2-对象内存布局" class="headerlink" title="2.2. 对象内存布局"></a>2.2. 对象内存布局</h2><p>在HotSpot中，对象在内存中的布局可以分为三部分：<strong>对象头、实例数据和对齐填充</strong>。</p><p><strong>Hotspot 虚拟机的对象头包括两部分信息</strong>，<strong>第一部分用于存储对象自身的运行时数据</strong>（哈希码、GC 分代年龄、锁状态标志等等），<strong>另一部分是类型指针</strong>，即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是那个类的实例。</p><p><strong>实例数据部分是对象真正存储的有效信息</strong>，也是在程序中所定义的各种类型的字段内容。</p><p><strong>对齐填充部分不是必然存在的，也没有什么特别的含义，仅仅起占位作用。</strong> 因为 Hotspot 虚拟机的自动内存管理系统要求对象起始地址必须是 8 字节的整数倍，换句话说就是对象的大小必须是 8 字节的整数倍。而对象头部分正好是 8 字节的倍数（1 倍或 2 倍），因此，当对象实例数据部分没有对齐时，就需要通过对齐填充来补全。</p><h2 id="2-3-对象的访问定位方式"><a href="#2-3-对象的访问定位方式" class="headerlink" title="2.3.  对象的访问定位方式"></a>2.3.  对象的访问定位方式</h2><p>Java程序通过栈上的 reference 数据来操作堆上的具体对象。对象的访问方式有虚拟机实现而定，目前主流的访问方式有使用句柄和直接指针两种</p><h3 id="2-3-1-使用句柄"><a href="#2-3-1-使用句柄" class="headerlink" title="2.3.1.  使用句柄"></a>2.3.1.  使用句柄</h3><p>使用句柄的话，那么Java堆中将会划分出一块内存来作为句柄池，reference 中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自的具体地址信息</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/xdmqp/myPic/main/img/%E5%AF%B9%E8%B1%A1%E7%9A%84%E8%AE%BF%E9%97%AE%E5%AE%9A%E4%BD%8D-%E4%BD%BF%E7%94%A8%E5%8F%A5%E6%9F%84.png" alt="对象的访问定位-使用句柄" title="">                </div>                <div class="image-caption">对象的访问定位-使用句柄</div>            </figure><h3 id="2-3-2-直接指针"><a href="#2-3-2-直接指针" class="headerlink" title="2.3.2.  直接指针"></a>2.3.2.  直接指针</h3><p>使用直接指针访问，那么 Java 堆对象的布局中就必须考虑如何放置访问类型数据的相关信息，而reference 中存储的直接就是对象的地址。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/xdmqp/myPic/main/img/%E5%AF%B9%E8%B1%A1%E7%9A%84%E8%AE%BF%E9%97%AE%E5%AE%9A%E4%BD%8D-%E7%9B%B4%E6%8E%A5%E6%8C%87%E9%92%88.png" alt="对象的访问定位-直接指针" title="">                </div>                <div class="image-caption">对象的访问定位-直接指针</div>            </figure><h3 id="2-3-3-对比"><a href="#2-3-3-对比" class="headerlink" title="2.3.3.  对比"></a>2.3.3.  对比</h3><p>这两种对象访问方式各有优势。<strong>使用句柄来访问的最大好处是 reference 中存储的是稳定的句柄地址，在对象被移动时只会改变句柄中的实例数据指针，而 reference 本身不需要修改。使用直接指针访问方式最大的好处就是速度快，它节省了一次指针定位的时间开销。</strong></p><h1 id="3-垃圾收集"><a href="#3-垃圾收集" class="headerlink" title="3.   垃圾收集"></a><strong>3.   垃圾收集</strong></h1><p>垃圾收集主要是针对堆和方法区进行。程序计数器、虚拟机栈和本地方法栈这三个区域属于线程私有的，只存在于线程的生命周期内，线程结束之后就会消失，因此不需要对这三个区域进行垃圾回收。</p><h2 id="3-1-判断一个对象是否可被回收"><a href="#3-1-判断一个对象是否可被回收" class="headerlink" title="3.1.    判断一个对象是否可被回收"></a>3.1.    判断一个对象是否可被回收</h2><h3 id="3-1-1-引用计数算法"><a href="#3-1-1-引用计数算法" class="headerlink" title="3.1.1.  引用计数算法"></a>3.1.1.  引用计数算法</h3><p>为对象添加一个引用计数器，当对象增加一个引用时计数器加 1，引用失效时计数器减 1。引用计数为 0 的对象可被回收。<br> 在两个对象出现循环引用的情况下，此时引用计数器永远不为 0，导致无法对它们进行回收。正是因为循环引用的存在，因此 Java 虚拟机不使用引用计数算法。</p><h3 id="3-1-2-可达性分析算法"><a href="#3-1-2-可达性分析算法" class="headerlink" title="3.1.2.  可达性分析算法"></a>3.1.2.  可达性分析算法</h3><p>以 GC Roots 为起始点进行搜索，可达的对象都是存活的，不可达的对象可被回收。<br> Java 虚拟机使用该算法来判断对象是否可被回收，GC Roots 一般包含以下内容：<br> 虚拟机栈中局部变量表中引用的对象<br> 本地方法栈中 JNI 中引用的对象<br> 方法区中类静态属性引用的对象<br> 方法区中的常量引用的对象</p><h3 id="3-1-3-方法区回收"><a href="#3-1-3-方法区回收" class="headerlink" title="3.1.3.  方法区回收"></a>3.1.3.  方法区回收</h3><p>因为方法区主要存放永久代对象，而永久代对象的回收率比新生代低很多，所以在方法区上进行回收性价比不高。<br> 主要是对常量池的回收和对类的卸载。<br> 为了避免内存溢出，在大量使用反射和动态代理的场景都需要虚拟机具备类卸载功能。<br> 类的卸载条件很多，需要满足以下三个条件，并且满足了条件也不一定会被卸载：<br> 该类所有的实例都已经被回收，此时堆中不存在该类的任何实例。<br> 加载该类的 ClassLoader 已经被回收。<br> 该类对应的 Class 对象没有在任何地方被引用，也就无法在任何地方通过反射访问该类方法。</p><h3 id="3-1-4-finalize"><a href="#3-1-4-finalize" class="headerlink" title="3.1.4.  finalize()"></a>3.1.4.  finalize()</h3><p>类似 C++ 的析构函数，用于关闭外部资源。但是 try-finally 等方式可以做得更好，并且该方法运行代价很高，不确定性大，无法保证各个对象的调用顺序，因此最好不要使用。<br> 当一个对象可被回收时，如果需要执行该对象的 finalize() 方法，那么就有可能在该方法中让对象重新被引用，从而实现自救。自救只能进行一次，如果回收的对象之前调用了 finalize() 方法自救，后面回收时不会再调用该方法。</p><h2 id="3-2-引用类型"><a href="#3-2-引用类型" class="headerlink" title="3.2.    引用类型"></a>3.2.    引用类型</h2><h3 id="3-2-1-强引用"><a href="#3-2-1-强引用" class="headerlink" title="3.2.1.  强引用"></a>3.2.1.  强引用</h3><p>被强引用关联的对象不会被回收。<br> 使用 new 一个新对象的方式来创建强引用。</p><h3 id="3-2-2-软引用"><a href="#3-2-2-软引用" class="headerlink" title="3.2.2.  软引用"></a>3.2.2.  软引用</h3><p>被软引用关联的对象只有在内存不够的情况下才会被回收。<br> 使用 SoftReference 类来创建软引用。</p><h3 id="3-2-3-弱引用"><a href="#3-2-3-弱引用" class="headerlink" title="3.2.3.  弱引用"></a>3.2.3.  弱引用</h3><p>被弱引用关联的对象一定会被回收，也就是说它只能存活到下一次垃圾回收发生之前。<br> 使用 WeakReference 类来创建弱引用。</p><h3 id="3-2-4-虚引用"><a href="#3-2-4-虚引用" class="headerlink" title="3.2.4.  虚引用"></a>3.2.4.  虚引用</h3><p>又称为幽灵引用或者幻影引用，一个对象是否有虚引用的存在，不会对其生存时间造成影响，也无法通过虚引用得到一个对象。<br> 为一个对象设置虚引用的唯一目的是能在这个对象被回收时收到一个系统通知。<br> 使用 PhantomReference 来创建虚引用。</p><h2 id="3-3-垃圾收集算法"><a href="#3-3-垃圾收集算法" class="headerlink" title="3.3.    垃圾收集算法"></a>3.3.    垃圾收集算法</h2><h3 id="3-3-1-标记-清除"><a href="#3-3-1-标记-清除" class="headerlink" title="3.3.1.  标记-清除"></a>3.3.1.  标记-清除</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/xdmqp/myPic/main/img/clip_image002.png" alt="desc" title="">                </div>                <div class="image-caption">desc</div>            </figure><p>在标记阶段，程序会检查每个对象是否为活动对象，如果是活动对象，则程序会在对象头部打上标记。<br> 在清除阶段，会进行对象回收并取消标志位，另外，还会判断回收后的分块与前一个空闲分块是否连续，若连续，会合并这两个分块。回收对象就是把对象作为分块，连接到被称为 “空闲链表” 的单向链表，之后进行分配时只需要遍历这个空闲链表，就可以找到分块。<br> 在分配时，程序会搜索空闲链表寻找空间大于等于新对象大小 size 的块 block。如果它找到的块等于 size，会直接返回这个分块；如果找到的块大于 size，会将块分割成大小为 size 与 (block - size) 的两部分，返回大小为 size 的分块，并把大小为 (block - size) 的块返回给空闲链表。<br> 不足：<br> 标记和清除过程效率都不高；<br> 会产生大量不连续的内存碎片，导致无法给大对象分配内存</p><h3 id="3-3-2-标记-整理"><a href="#3-3-2-标记-整理" class="headerlink" title="3.3.2.  标记-整理"></a>3.3.2.  标记-整理</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/xdmqp/myPic/main/img/clip_image004.png" alt="desc" title="">                </div>                <div class="image-caption">desc</div>            </figure><p>让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。<br> 优点：不会产生内存碎片<br> 不足：需要移动大量对象，处理效率比较低</p><h3 id="3-3-3-标记-复制"><a href="#3-3-3-标记-复制" class="headerlink" title="3.3.3.  标记-复制"></a>3.3.3.  标记-复制</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/xdmqp/myPic/main/img/clip_image006.png" alt="desc" title="">                </div>                <div class="image-caption">desc</div>            </figure><p>将内存划分为大小相等的两块，每次只使用其中一块，当这一块内存用完了就将还存活的对象复制到另一块上面，然后再把使用过的内存空间进行一次清理。<br> 主要不足是只使用了内存的一半。<br> 现在的商业虚拟机都采用这种收集算法回收新生代，但是并不是划分为大小相等的两块，而是一块较大的 Eden 空间和两块较小的 Survivor 空间，每次使用 Eden 和其中一块 Survivor。在回收时，将 Eden 和 Survivor 中还存活着的对象全部复制到另一块 Survivor 上，最后清理 Eden 和使用过的那一块 Survivor。<br> HotSpot 虚拟机的 Eden 和 Survivor 大小比例默认为 8:1，保证了内存的利用率达到 90%。如果每次回收有多于 10% 的对象存活，那么一块 Survivor 就不够用了，此时需要依赖于老年代进行空间分配担保，也就是借用老年代的空间存储放不下的对象。</p><h3 id="3-3-4-分代收集"><a href="#3-3-4-分代收集" class="headerlink" title="3.3.4.  分代收集"></a>3.3.4.  分代收集</h3><p>现在的商业虚拟机采用分代收集算法，它根据对象存活周期将内存划分为几块，不同块采用适当的收集算法。<br> 一般将堆分为新生代和老年代。<br> 新生代使用：复制算法<br> 老年代使用：标记-清除或者标记-整理</p><h2 id="3-4-垃圾收集器"><a href="#3-4-垃圾收集器" class="headerlink" title="3.4.    垃圾收集器"></a>3.4.    垃圾收集器</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/xdmqp/myPic/main/img/clip_image008.png" alt="desc" title="">                </div>                <div class="image-caption">desc</div>            </figure><p>以上是 HotSpot 虚拟机中的 7 个垃圾收集器，连线表示垃圾收集器可以配合使用。<br> 单线程与多线程：单线程指的是垃圾收集器只使用一个线程，而多线程使用多个线程；<br> 串行与并行：串行指的是垃圾收集器与用户程序交替执行，这意味着在执行垃圾收集的时候需要停顿用户程序；并行指的是垃圾收集器和用户程序同时执行。除了 CMS 和 G1 之外，其它垃圾收集器都是以串行的方式执行。</p><h3 id="3-4-1-1-Serial收集器"><a href="#3-4-1-1-Serial收集器" class="headerlink" title="3.4.1.  1.Serial收集器"></a>3.4.1.  1.Serial收集器</h3><p>Serial 翻译为串行，也就是说它以串行的方式执行。<br> 它是单线程的收集器，只会使用一个线程进行垃圾收集工作。<br> 它的优点是简单高效，在单个 CPU 环境下，由于没有线程交互的开销，因此拥有最高的单线程收集效率。<br> 它是 Client 场景下的默认新生代收集器，因为在该场景下内存一般来说不会很大。它收集一两百兆垃圾的停顿时间可以控制在一百多毫秒以内，只要不是太频繁，这点停顿时间是可以接受的。</p><h3 id="3-4-2-2-ParNew收集器"><a href="#3-4-2-2-ParNew收集器" class="headerlink" title="3.4.2.  2.ParNew收集器"></a>3.4.2.  2.ParNew收集器</h3><p>它是 Serial 收集器的多线程版本。<br> 它是 Server 场景下默认的新生代收集器，除了性能原因外，主要是因为除了 Serial 收集器，只有它能与 CMS 收集器配合使用。</p><h3 id="3-4-3-3-Parallel-Scavenge-收集器"><a href="#3-4-3-3-Parallel-Scavenge-收集器" class="headerlink" title="3.4.3.  3.Parallel Scavenge 收集器"></a>3.4.3.  3.Parallel Scavenge 收集器</h3><p>与 ParNew 一样是多线程收集器。<br> 其它收集器目标是尽可能缩短垃圾收集时用户线程的停顿时间，而它的目标是达到一个可控制的吞吐量，因此它被称为“吞吐量优先”收集器。这里的吞吐量指 CPU 用于运行用户程序的时间占总时间的比值。<br> 停顿时间越短就越适合需要与用户交互的程序，良好的响应速度能提升用户体验。而高吞吐量则可以高效率地利用 CPU 时间，尽快完成程序的运算任务，适合在后台运算而不需要太多交互的任务。<br> 缩短停顿时间是以牺牲吞吐量和新生代空间来换取的：新生代空间变小，垃圾回收变得频繁，导致吞吐量下降。<br> 可以通过一个开关参数打开 GC 自适应的调节策略（GC Ergonomics），就不需要手工指定新生代的大小（-Xmn）、Eden 和 Survivor 区的比例、晋升老年代对象年龄等细节参数了。虚拟机会根据当前系统的运行情况收集性能监控信息，动态调整这些参数以提供最合适的停顿时间或者最大的吞吐量。</p><h3 id="3-4-4-4-Serial-Old收集器"><a href="#3-4-4-4-Serial-Old收集器" class="headerlink" title="3.4.4.  4.Serial Old收集器"></a>3.4.4.  4.Serial Old收集器</h3><p>是 Serial 收集器的老年代版本，也是给 Client 场景下的虚拟机使用。如果用在 Server 场景下，它有两大用途：<br> 在 JDK 1.5 以及之前版本（Parallel Old 诞生以前）中与 Parallel Scavenge 收集器搭配使用。<br> 作为 CMS 收集器的后备预案，在并发收集发生 Concurrent Mode Failure 时使用。</p><h3 id="3-4-5-5-Parallel-Old收集器"><a href="#3-4-5-5-Parallel-Old收集器" class="headerlink" title="3.4.5.  5.Parallel Old收集器"></a>3.4.5.  5.Parallel Old收集器</h3><p>是 Parallel Scavenge 收集器的老年代版本。<br> 在注重吞吐量以及 CPU 资源敏感的场合，都可以优先考虑 Parallel Scavenge 加 Parallel Old 收集器。</p><h3 id="3-4-6-6-CMS收集器"><a href="#3-4-6-6-CMS收集器" class="headerlink" title="3.4.6.  6.CMS收集器"></a>3.4.6.  6.CMS收集器</h3><p>CMS（Concurrent Mark Sweep），Mark Sweep 指的是标记 - 清除算法。<br> 分为以下四个流程：<br> 初始标记：仅仅只是标记一下 GC Roots 能直接关联到的对象，速度很快，需要停顿。<br> 并发标记：进行 GC Roots Tracing 的过程，它在整个回收过程中耗时最长，不需要停顿。<br> 重新标记：为了修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，需要停顿。<br> 并发清除：不需要停顿。<br> 在整个过程中耗时最长的并发标记和并发清除过程中，收集器线程都可以与用户线程一起工作，不需要进行停顿。<br> 具有以下缺点：<br> 吞吐量低：低停顿时间是以牺牲吞吐量为代价的，导致 CPU 利用率不够高。<br> 无法处理浮动垃圾，可能出现 Concurrent Mode Failure。浮动垃圾是指并发清除阶段由于用户线程继续运行而产生的垃圾，这部分垃圾只能到下一次 GC 时才能进行回收。由于浮动垃圾的存在，因此需要预留出一部分内存，意味着 CMS 收集不能像其它收集器那样等待老年代快满的时候再回收。如果预留的内存不够存放浮动垃圾，就会出现 Concurrent Mode Failure，这时虚拟机将临时启用 Serial Old 来替代 CMS。<br> 标记 - 清除算法导致的空间碎片，往往出现老年代空间剩余，但无法找到足够大连续空间来分配当前对象，不得不提前触发一次 Full GC。</p><h3 id="3-4-7-7-G1收集器"><a href="#3-4-7-7-G1收集器" class="headerlink" title="3.4.7.  7.G1收集器"></a>3.4.7.  7.G1收集器</h3><p>G1（Garbage-First），它是一款面向服务端应用的垃圾收集器，在多 CPU 和大内存的场景下有很好的性能。HotSpot 开发团队赋予它的使命是未来可以替换掉 CMS 收集器。<br> 堆被分为新生代和老年代，其它收集器进行收集的范围都是整个新生代或者老年代，而 G1 可以直接对新生代和老年代一起回收。<br> G1 把堆划分成多个大小相等的独立区域（Region），新生代和老年代不再物理隔离。<br> 通过引入 Region 的概念，从而将原来的一整块内存空间划分成多个的小空间，使得每个小空间可以单独进行垃圾回收。这种划分方法带来了很大的灵活性，使得可预测的停顿时间模型成为可能。通过记录每个 Region 垃圾回收时间以及回收所获得的空间（这两个值是通过过去回收的经验获得），并维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的 Region。<br> 每个 Region 都有一个 Remembered Set，用来记录该 Region 对象的引用对象所在的 Region。通过使用 Remembered Set，在做可达性分析的时候就可以避免全堆扫描。<br> 如果不计算维护 Remembered Set 的操作，G1 收集器的运作大致可划分为以下几个步骤：<br> 初始标记<br> 并发标记<br> 最终标记：为了修正在并发标记期间因用户程序继续运作而导致标记产生变动的那一部分标记记录，虚拟机将这段时间对象变化记录在线程的 Remembered Set Logs 里面，最终标记阶段需要把 Remembered Set Logs 的数据合并到 Remembered Set 中。这阶段需要停顿线程，但是可并行执行。<br> 筛选回收：首先对各个 Region 中的回收价值和成本进行排序，根据用户所期望的 GC 停顿时间来制定回收计划。此阶段其实也可以做到与用户程序一起并发执行，但是因为只回收一部分 Region，时间是用户可控制的，而且停顿用户线程将大幅度提高收集效率。<br> 具备如下特点：<br> 空间整合：整体来看是基于“标记 - 整理”算法实现的收集器，从局部（两个 Region 之间）上来看是基于“复制”算法实现的，这意味着运行期间不会产生内存空间碎片。<br> 可预测的停顿：能让使用者明确指定在一个长度为 M 毫秒的时间片段内，消耗在 GC 上的时间不得超过 N 毫秒。</p><h3 id="3-4-8-8-ZGC收集器"><a href="#3-4-8-8-ZGC收集器" class="headerlink" title="3.4.8.  8.ZGC收集器"></a>3.4.8.  8.ZGC收集器</h3><h1 id="4-内存分配与回收"><a href="#4-内存分配与回收" class="headerlink" title="4.   内存分配与回收"></a>4.   内存分配与回收</h1><h2 id="4-1-Minor-GC和Full-GC"><a href="#4-1-Minor-GC和Full-GC" class="headerlink" title="4.1.    Minor GC和Full GC"></a>4.1.    Minor GC和Full GC</h2><p>Minor GC：回收新生代，因为新生代对象存活时间很短，因此 Minor GC 会频繁执行，执行的速度一般也会比较快。<br> Full GC：回收老年代和新生代，老年代对象其存活时间长，因此 Full GC 很少执行，执行速度会比 Minor GC 慢很多。</p><h2 id="4-2-内存分配策略"><a href="#4-2-内存分配策略" class="headerlink" title="4.2.    内存分配策略"></a>4.2.    内存分配策略</h2><h3 id="4-2-1-1-对象优先在Eden分配"><a href="#4-2-1-1-对象优先在Eden分配" class="headerlink" title="4.2.1.  1.对象优先在Eden分配"></a>4.2.1.  1.对象优先在Eden分配</h3><p>大多数情况下，对象在新生代 Eden 上分配，当 Eden 空间不够时，发起 Minor GC。</p><h3 id="4-2-2-2-大对象直接进入老年代"><a href="#4-2-2-2-大对象直接进入老年代" class="headerlink" title="4.2.2.  2.大对象直接进入老年代"></a>4.2.2.  2.大对象直接进入老年代</h3><p>大对象是指需要连续内存空间的对象，最典型的大对象是那种很长的字符串以及数组。<br> 经常出现大对象会提前触发垃圾收集以获取足够的连续空间分配给大对象。<br> -XX:PretenureSizeThreshold，大于此值的对象直接在老年代分配，避免在 Eden 和 Survivor 之间的大量内存复制。</p><h3 id="4-2-3-3-长期存活的对象进入老年代"><a href="#4-2-3-3-长期存活的对象进入老年代" class="headerlink" title="4.2.3.  3.长期存活的对象进入老年代"></a>4.2.3.  3.长期存活的对象进入老年代</h3><p>为对象定义年龄计数器，对象在 Eden 出生并经过 Minor GC 依然存活，将移动到 Survivor 中，年龄就增加 1 岁，增加到一定年龄则移动到老年代中。<br> -XX:MaxTenuringThreshold 用来定义年龄的阈值。</p><h3 id="4-2-4-4-动态对象年龄判定"><a href="#4-2-4-4-动态对象年龄判定" class="headerlink" title="4.2.4.  4.动态对象年龄判定"></a>4.2.4.  4.动态对象年龄判定</h3><p>虚拟机并不是永远要求对象的年龄必须达到 MaxTenuringThreshold 才能晋升老年代，如果在 Survivor 中相同年龄所有对象大小的总和大于 Survivor 空间的一半，则年龄大于或等于该年龄的对象可以直接进入老年代，无需等到 MaxTenuringThreshold 中要求的年龄。</p><h3 id="4-2-5-5-空间分配担保"><a href="#4-2-5-5-空间分配担保" class="headerlink" title="4.2.5.  5.空间分配担保"></a>4.2.5.  5.空间分配担保</h3><p>在发生 Minor GC 之前，虚拟机先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果条件成立的话，那么 Minor GC 可以确认是安全的。<br> 如果不成立的话虚拟机会查看 HandlePromotionFailure 的值是否允许担保失败，如果允许那么就会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试着进行一次 Minor GC；如果小于，或者 HandlePromotionFailure 的值不允许冒险，那么就要进行一次 Full GC。</p><h2 id="4-3-Full-GC的触发条件"><a href="#4-3-Full-GC的触发条件" class="headerlink" title="4.3.    Full GC的触发条件"></a>4.3.    Full GC的触发条件</h2><p>对于 Minor GC，其触发条件非常简单，当 Eden 空间满时，就将触发一次 Minor GC。而 Full GC 则相对复杂，有以下条件：<br> 调用System.gc()：只是建议虚拟机执行 Full GC，但是虚拟机不一定真正去执行。不建议使用这种方式，而是让虚拟机管理内存。<br> 老年代空间不足：老年代空间不足的常见场景为前文所讲的大对象直接进入老年代、长期存活的对象进入老年代等。为了避免以上原因引起的 Full GC，应当尽量不要创建过大的对象以及数组。除此之外，可以通过 -Xmn 虚拟机参数调大新生代的大小，让对象尽量在新生代被回收掉，不进入老年代。还可以通过 -XX:MaxTenuringThreshold 调大对象进入老年代的年龄，让对象在新生代多存活一段时间。<br> 空间分配担保失败：使用复制算法的 Minor GC 需要老年代的内存空间作担保，如果担保失败会执行一次 Full GC。<br> JDK1.7及以前的永久代空间不足：在 JDK 1.7 及以前，HotSpot 虚拟机中的方法区是用永久代实现的，永久代中存放的为一些 Class 的信息、常量、静态变量等数据。当系统中要加载的类、反射的类和调用的方法较多时，永久代可能会被占满，在未配置为采用 CMS GC 的情况下也会执行 Full GC。如果经过 Full GC 仍然回收不了，那么虚拟机会抛出 java.lang.OutOfMemoryError。为避免以上原因引起的 Full GC，可采用的方法为增大永久代空间或转为使用 CMS GC。<br> Concurrent Mode Failure：执行 CMS GC 的过程中同时有对象要放入老年代，而此时老年代空间不足（可能是 GC 过程中浮动垃圾过多导致暂时性的空间不足），便会报 Concurrent Mode Failure 错误，并触发 Full GC。</p><h1 id="5-类加载机制"><a href="#5-类加载机制" class="headerlink" title="5.   类加载机制"></a>5.   类加载机制</h1><p>类是在运行期间第一次使用时动态加载的，而不是一次性加载所有类。因为如果一次性加载，那么会占用很多的内存。</p><h2 id="5-1-类的生命周期"><a href="#5-1-类的生命周期" class="headerlink" title="5.1.    类的生命周期"></a>5.1.    类的生命周期</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/xdmqp/myPic/main/img/335fe19c-4a76-45ab-9320-88c90d6a0d7e.png" alt="img" title="">                </div>                <div class="image-caption">img</div>            </figure><p>包含7个阶段：加载、验证、准备、解析、初始化、使用、卸载</p><h2 id="5-2-类加载过程"><a href="#5-2-类加载过程" class="headerlink" title="5.2.    类加载过程"></a>5.2.    类加载过程</h2><h3 id="5-2-1-加载"><a href="#5-2-1-加载" class="headerlink" title="5.2.1.  加载"></a>5.2.1.  加载</h3><p>加载是类加载的一个阶段，注意不要混淆。<br> 加载过程完成三件事：<br> 通过类的完全限定名称获取定义该类的二进制字节流。<br> 将该字节流表示的静态存储结构转换为方法区的运行时存储结构。<br> 在内存中生成一个代表该类的 Class 对象，作为方法区中该类各种数据的访问入口。</p><h3 id="5-2-2-验证"><a href="#5-2-2-验证" class="headerlink" title="5.2.2.  验证"></a>5.2.2.  验证</h3><p>确保 Class 文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。</p><h3 id="5-2-3-准备"><a href="#5-2-3-准备" class="headerlink" title="5.2.3.  准备"></a>5.2.3.  准备</h3><p>类变量是被 static 修饰的变量，准备阶段为类变量分配内存并设置初始值，使用的是方法区的内存。<br> 实例变量不会在这阶段分配内存，它会在对象实例化时随着对象一起被分配在堆中。应该注意到，实例化不是类加载的一个过程，类加载发生在所有实例化操作之前，并且类加载只进行一次，实例化可以进行多次。<br> 初始值一般为0值，如果类常量是常量（final修饰），那么将初始化为表达式所定义的值而不是 0。</p><h3 id="5-2-4-解析"><a href="#5-2-4-解析" class="headerlink" title="5.2.4.  解析"></a>5.2.4.  解析</h3><p>将常量池的符号引用替换为直接引用的过程。<br> 其中解析过程在某些情况下可以在初始化阶段之后再开始，这是为了支持 Java 的动态绑定。</p><h3 id="5-2-5-初始化"><a href="#5-2-5-初始化" class="headerlink" title="5.2.5.  初始化"></a>5.2.5.  初始化</h3><p>初始化阶段才真正开始执行类中定义的 Java 程序代码。初始化阶段是虚拟机执行类构造器 <clinit>() 方法的过程。在准备阶段，类变量已经赋过一次系统要求的初始值，而在初始化阶段，根据程序员通过程序制定的主观计划去初始化类变量和其它资源。<br> <clinit>() 是由编译器自动收集类中所有类变量的赋值动作和静态语句块中的语句合并产生的，编译器收集的顺序由语句在源文件中出现的顺序决定。特别注意的是，静态语句块只能访问到定义在它之前的类变量，定义在它之后的类变量只能赋值，不能访问。<br> 由于父类的 <clinit>() 方法先执行，也就意味着父类中定义的静态语句块的执行要优先于子类。<br> 接口中不可以使用静态语句块，但仍然有类变量初始化的赋值操作，因此接口与类一样都会生成 <clinit>() 方法。但接口与类不同的是，执行接口的 <clinit>() 方法不需要先执行父接口的 <clinit>() 方法。只有当父接口中定义的变量使用时，父接口才会初始化。另外，接口的实现类在初始化时也一样不会执行接口的 <clinit>() 方法。<br> 虚拟机会保证一个类的 <clinit>() 方法在多线程环境下被正确的加锁和同步，如果多个线程同时初始化一个类，只会有一个线程执行这个类的 <clinit>() 方法，其它线程都会阻塞等待，直到活动线程执行 <clinit>() 方法完毕。如果在一个类的 <clinit>() 方法中有耗时的操作，就可能造成多个线程阻塞，在实际过程中此种阻塞很隐蔽。</p><h2 id="5-3-类初始化时机"><a href="#5-3-类初始化时机" class="headerlink" title="5.3.    类初始化时机"></a>5.3.    类初始化时机</h2><h3 id="5-3-1-主动引用"><a href="#5-3-1-主动引用" class="headerlink" title="5.3.1.  主动引用"></a>5.3.1.  主动引用</h3><p>虚拟机规范中并没有强制约束何时进行加载，但是规范严格规定了有且只有下列五种情况必须对类进行初始化（加载、验证、准备都会随之发生）：<br> 遇到 new、getstatic、putstatic、invokestatic 这四条字节码指令时，如果类没有进行过初始化，则必须先触发其初始化。最常见的生成这 4 条指令的场景是：使用 new 关键字实例化对象的时候；读取或设置一个类的静态字段（被 final 修饰、已在编译期把结果放入常量池的静态字段除外）的时候；以及调用一个类的静态方法的时候。<br> 使用 java.lang.reflect 包的方法对类进行反射调用的时候，如果类没有进行初始化，则需要先触发其初始化。<br> 当初始化一个类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化。<br> 当虚拟机启动时，用户需要指定一个要执行的主类（包含 main() 方法的那个类），虚拟机会先初始化这个主类；<br> 当使用 JDK 1.7 的动态语言支持时，如果一个 java.lang.invoke.MethodHandle 实例最后的解析结果为 REF_getStatic, REF_putStatic, REF_invokeStatic 的方法句柄，并且这个方法句柄所对应的类没有进行过初始化，则需要先触发其初始化；</p><h3 id="5-3-2-被动引用"><a href="#5-3-2-被动引用" class="headerlink" title="5.3.2.  被动引用"></a>5.3.2.  被动引用</h3><p>以上 5 种场景中的行为称为对一个类进行主动引用。除此之外，所有引用类的方式都不会触发初始化，称为被动引用。被动引用的常见例子包括：<br> 通过子类引用父类的静态字段，不会导致子类初始化。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(SubClass.value);  <span class="comment">// value 字段在 SuperClass 中定义</span></span><br></pre></td></tr></table></figure><p> 通过数组定义来引用类，不会触发此类的初始化。该过程会对数组类进行初始化，数组类是一个由虚拟机自动生成的、直接继承自 Object 的子类，其中包含了数组的属性和方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SuperClass[] sca = <span class="keyword">new</span> SuperClass[<span class="number">10</span>];</span><br></pre></td></tr></table></figure><p> 常量在编译阶段会存入调用类的常量池中，本质上并没有直接引用到定义常量的类，因此不会触发定义常量的类的初始化。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(ConstClass.HELLOWORLD);</span><br></pre></td></tr></table></figure><h2 id="5-4-类与类加载器"><a href="#5-4-类与类加载器" class="headerlink" title="5.4.    类与类加载器"></a>5.4.    类与类加载器</h2><p>两个类相等，需要类本身相等，并且使用同一个类加载器进行加载。这是因为每一个类加载器都拥有一个独立的类名称空间。<br> 这里的相等，包括类的 Class 对象的 equals() 方法、isAssignableFrom() 方法、isInstance() 方法的返回结果为 true，也包括使用 instanceof 关键字做对象所属关系判定结果为 true。</p><h2 id="5-5-类加载器分类"><a href="#5-5-类加载器分类" class="headerlink" title="5.5.    类加载器分类"></a>5.5.    类加载器分类</h2><p>从 Java 虚拟机的角度来讲，只存在以下两种不同的类加载器：<br> 启动类加载器（Bootstrap ClassLoader），使用 C++ 实现，是虚拟机自身的一部分；<br> 所有其它类的加载器，使用 Java 实现，独立于虚拟机，继承自抽象类 java.lang.ClassLoader。<br> 从 Java 开发人员的角度看，类加载器可以划分得更细致一些：<br> 启动类加载器（Bootstrap ClassLoader）此类加载器负责将存放在 <JRE_HOME>\lib 目录中的，或者被 -Xbootclasspath 参数所指定的路径中的，并且是虚拟机识别的（仅按照文件名识别，如 rt.jar，名字不符合的类库即使放在 lib 目录中也不会被加载）类库加载到虚拟机内存中。启动类加载器无法被 Java 程序直接引用，用户在编写自定义类加载器时，如果需要把加载请求委派给启动类加载器，直接使用 null 代替即可。<br> 扩展类加载器（Extension ClassLoader）这个类加载器是由 ExtClassLoader（sun.misc.Launcher$ExtClassLoader）实现的。它负责将 <JAVA_HOME>/lib/ext 或者被 java.ext.dir 系统变量所指定路径中的所有类库加载到内存中，开发者可以直接使用扩展类加载器。<br> 应用程序类加载器（Application ClassLoader）这个类加载器是由 AppClassLoader（sun.misc.Launcher$AppClassLoader）实现的。由于这个类加载器是 ClassLoader 中的 getSystemClassLoader() 方法的返回值，因此一般称为系统类加载器。它负责加载用户类路径（ClassPath）上所指定的类库，开发者可以直接使用这个类加载器，如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。</p><h2 id="5-6-双亲委派模型"><a href="#5-6-双亲委派模型" class="headerlink" title="5.6.    双亲委派模型"></a>5.6.    双亲委派模型</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/xdmqp/myPic/main/img/0dd2d40a-5b2b-4d45-b176-e75a4cd4bdbf.png" alt="img" title="">                </div>                <div class="image-caption">img</div>            </figure><p>应用程序是由三种类加载器互相配合从而实现类加载，除此之外还可以加入自己定义的类加载器。<br> 下图展示了类加载器之间的层次关系，称为双亲委派模型（Parents Delegation Model）。该模型要求除了顶层的启动类加载器外，其它的类加载器都要有自己的父类加载器。这里的父子关系一般通过组合关系（Composition）来实现，而不是继承关系（Inheritance）。</p><h3 id="5-6-1-工作过程"><a href="#5-6-1-工作过程" class="headerlink" title="5.6.1.  工作过程"></a>5.6.1.  工作过程</h3><p>一个类加载器首先将类加载请求转发到父类加载器，只有当父类加载器无法完成时才尝试自己加载。</p><h3 id="5-6-2-好处"><a href="#5-6-2-好处" class="headerlink" title="5.6.2.  好处"></a>5.6.2.  好处</h3><p>使得 Java 类随着它的类加载器一起具有一种带有优先级的层次关系，从而使得基础类得到统一。<br> 例如 java.lang.Object 存放在 rt.jar 中，如果编写另外一个 java.lang.Object 并放到 ClassPath 中，程序可以编译通过。由于双亲委派模型的存在，所以在 rt.jar 中的 Object 比在 ClassPath 中的 Object 优先级更高，这是因为 rt.jar 中的 Object 使用的是启动类加载器，而 ClassPath 中的 Object 使用的是应用程序类加载器。rt.jar 中的 Object 优先级更高，那么程序中所有的 Object 都是这个 Object。</p><h3 id="5-6-3-实现"><a href="#5-6-3-实现" class="headerlink" title="5.6.3.  实现"></a>5.6.3.  实现</h3><p>以下是抽象类 java.lang.ClassLoader 的代码片段，其中的 loadClass() 方法运行过程如下：先检查类是否已经加载过，如果没有则让父类加载器去加载。当父类加载器加载失败时抛出 ClassNotFoundException，此时尝试自己去加载。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassLoader</span> </span>&#123;</span><br><span class="line">    <span class="comment">// The parent class loader for delegation</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ClassLoader parent;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Class&lt;?&gt; loadClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        <span class="keyword">return</span> loadClass(name, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="keyword">boolean</span> resolve) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (getClassLoadingLock(name)) &#123;</span><br><span class="line">            <span class="comment">// First, check if the class has already been loaded</span></span><br><span class="line">            Class&lt;?&gt; c = findLoadedClass(name);</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        c = parent.loadClass(name, <span class="keyword">false</span>);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        c = findBootstrapClassOrNull(name);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">                    <span class="comment">// ClassNotFoundException thrown if class not found</span></span><br><span class="line">                    <span class="comment">// from the non-null parent class loader</span></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// If still not found, then invoke findClass in order</span></span><br><span class="line">                    <span class="comment">// to find the class.</span></span><br><span class="line">                    c = findClass(name);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (resolve) &#123;</span><br><span class="line">                resolveClass(c);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> c;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ClassNotFoundException(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-7-自定义类加载器实现"><a href="#5-7-自定义类加载器实现" class="headerlink" title="5.7.    自定义类加载器实现"></a>5.7.    自定义类加载器实现</h2><p>以下代码中的 FileSystemClassLoader 是自定义类加载器，继承自 java.lang.ClassLoader，用于加载文件系统上的类。它首先根据类的全名在文件系统上查找类的字节代码文件（.class 文件），然后读取该文件内容，最后通过 defineClass() 方法来把这些字节代码转换成 java.lang.Class 类的实例。</p><p>java.lang.ClassLoader 的 loadClass() 实现了双亲委派模型的逻辑，自定义类加载器一般不去重写它，但是需要重写 findClass() 方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileSystemClassLoader</span> <span class="keyword">extends</span> <span class="title">ClassLoader</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String rootDir;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FileSystemClassLoader</span><span class="params">(String rootDir)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.rootDir = rootDir;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        <span class="keyword">byte</span>[] classData = getClassData(name);</span><br><span class="line">        <span class="keyword">if</span> (classData == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ClassNotFoundException();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> defineClass(name, classData, <span class="number">0</span>, classData.length);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">byte</span>[] getClassData(String className) &#123;</span><br><span class="line">        String path = classNameToPath(className);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            InputStream ins = <span class="keyword">new</span> FileInputStream(path);</span><br><span class="line">            ByteArrayOutputStream baos = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">            <span class="keyword">int</span> bufferSize = <span class="number">4096</span>;</span><br><span class="line">            <span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[bufferSize];</span><br><span class="line">            <span class="keyword">int</span> bytesNumRead;</span><br><span class="line">            <span class="keyword">while</span> ((bytesNumRead = ins.read(buffer)) != -<span class="number">1</span>) &#123;</span><br><span class="line">                baos.write(buffer, <span class="number">0</span>, bytesNumRead);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> baos.toByteArray();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">classNameToPath</span><span class="params">(String className)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> rootDir + File.separatorChar</span><br><span class="line">                + className.replace(<span class="string">'.'</span>, File.separatorChar) + <span class="string">".class"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>CS-Notes：<a href="https://www.cyc2018.xyz/Java/Java%20%E8%99%9A%E6%8B%9F%E6%9C%BA.html" target="_blank" rel="noopener">https://www.cyc2018.xyz/Java/Java%20%E8%99%9A%E6%8B%9F%E6%9C%BA.html</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-运行时数据区域&quot;&gt;&lt;a href=&quot;#1-运行时数据区域&quot; class=&quot;headerlink&quot; title=&quot;1.   运行时数据区域&quot;&gt;&lt;/a&gt;1.   运行时数据区域&lt;/h1&gt;&lt;h2 id=&quot;1-1-程序计数器&quot;&gt;&lt;a href=&quot;#1-1-程序计数器&quot;
      
    
    </summary>
    
    
      <category term="Java" scheme="https://xdmqp.github.io/categories/Java/"/>
    
    
      <category term="Java" scheme="https://xdmqp.github.io/tags/Java/"/>
    
      <category term="JVM" scheme="https://xdmqp.github.io/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>排序算法汇总</title>
    <link href="https://xdmqp.github.io/2021/02/28/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%B1%87%E6%80%BB/"/>
    <id>https://xdmqp.github.io/2021/02/28/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%B1%87%E6%80%BB/</id>
    <published>2021-02-27T16:00:00.000Z</published>
    <updated>2021-07-10T14:09:07.607Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-冒泡排序"><a href="#1-冒泡排序" class="headerlink" title="1.冒泡排序"></a>1.冒泡排序</h3><h4 id="1-1算法描述"><a href="#1-1算法描述" class="headerlink" title="1.1算法描述"></a>1.1算法描述</h4><ul><li>比较相邻元素，如果第一个比第二个大，则交换两者；</li><li>对每一对相邻元素做同样工作，从开始一对到最后一对，最后一个元素即为最大的数；</li><li>将已经确定大小的元素排除在外，对剩余的所有元素继续重复上述步骤</li></ul><h4 id="1-2动画演示"><a href="#1-2动画演示" class="headerlink" title="1.2动画演示"></a>1.2动画演示</h4><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://images2017.cnblogs.com/blog/849589/201710/849589-20171015223238449-2146169197.gif" alt="img" title="">                </div>                <div class="image-caption">img</div>            </figure><h4 id="1-3基本代码实现"><a href="#1-3基本代码实现" class="headerlink" title="1.3基本代码实现"></a>1.3基本代码实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bubbleSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = arr.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; len - i - <span class="number">1</span>; j++) &#123;</span><br><span class="line">            <span class="comment">//相邻元素两两对比</span></span><br><span class="line">            <span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="comment">//元素交换</span></span><br><span class="line">                <span class="keyword">int</span> temp = arr[j];</span><br><span class="line">                arr[j] = arr[j + <span class="number">1</span>];</span><br><span class="line">                arr[j + <span class="number">1</span>] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-选择排序"><a href="#2-选择排序" class="headerlink" title="2.选择排序"></a>2.选择排序</h3><h4 id="2-1算法描述"><a href="#2-1算法描述" class="headerlink" title="2.1算法描述"></a>2.1算法描述</h4><ul><li><p>初始状态：无序区[1,n],有序区为空；</p></li><li><p>第i趟排序(i=1,2,3…n-1)开始时，当前有序区和无序区分别为R[1..i-1]和R(i..n）。该趟排序从当前无序区中-选出关键字最小的记录 R[k]，将它与无序区的第1个记录R交换，使R[1..i]和R[i+1..n)分别变为记录个数增加1个的新有序区和记录个数减少1个的新无序区；</p></li><li><p>经过n-1趟排序，数据有序</p></li></ul><h4 id="2-2动画演示"><a href="#2-2动画演示" class="headerlink" title="2.2动画演示"></a>2.2动画演示</h4><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://images2017.cnblogs.com/blog/849589/201710/849589-20171015224719590-1433219824.gif" alt="img" title="">                </div>                <div class="image-caption">img</div>            </figure><h4 id="2-3基本代码实现"><a href="#2-3基本代码实现" class="headerlink" title="2.3基本代码实现"></a>2.3基本代码实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">selectionSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = arr.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> minIndex = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; len; j++) &#123;</span><br><span class="line">            <span class="comment">//如果遍历元素小于当前保存最小值</span></span><br><span class="line">            <span class="keyword">if</span> (arr[j] &lt; arr[minIndex]) &#123;</span><br><span class="line">                minIndex = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (minIndex != i) &#123;</span><br><span class="line">            <span class="keyword">int</span> temp = arr[i];</span><br><span class="line">            arr[i] = arr[minIndex];</span><br><span class="line">            arr[minIndex] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-直接插入排序"><a href="#3-直接插入排序" class="headerlink" title="3.直接插入排序"></a>3.直接插入排序</h3><h4 id="3-1算法描述"><a href="#3-1算法描述" class="headerlink" title="3.1算法描述"></a>3.1算法描述</h4><ul><li>从第1个元素开始，默认其已经被排序；</li><li>取出下一个元素，在已经排序的元素序列中由后向前扫描；</li><li>如果当前扫描的元素大于新元素，将该元素向后移动一位；</li><li>重复步骤3，直至找到当前扫描元素小于或者等于新元素的位置；</li><li>将新元素插入到该位置后；</li><li>重复步骤2-5</li></ul><h4 id="3-2动画演示"><a href="#3-2动画演示" class="headerlink" title="3.2动画演示"></a>3.2动画演示</h4><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://images2017.cnblogs.com/blog/849589/201710/849589-20171015225645277-1151100000.gif" alt="img" title="">                </div>                <div class="image-caption">img</div>            </figure><h4 id="3-3基本代码实现"><a href="#3-3基本代码实现" class="headerlink" title="3.3基本代码实现"></a>3.3基本代码实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">insertionSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = arr.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> current = arr[i], j;</span><br><span class="line">        <span class="keyword">for</span> (j = i - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">            <span class="comment">//扫描元素大于新元素，将其后移一位</span></span><br><span class="line">            <span class="keyword">if</span> (arr[j] &gt; current) &#123;</span><br><span class="line">                arr[j + <span class="number">1</span>] = arr[j];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;<span class="comment">//扫描元素小于等于新元素，将新元素放在其后面一位</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        arr[j + <span class="number">1</span>] = current;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-希尔排序"><a href="#4-希尔排序" class="headerlink" title="4.希尔排序"></a>4.希尔排序</h3><h4 id="4-1算法描述"><a href="#4-1算法描述" class="headerlink" title="4.1算法描述"></a>4.1算法描述</h4><p>希尔排序采用跳跃式分组的策略，通过增量gap将数组元素划分为若干组，然后分组内进行插入排序，随后逐步缩小增量，继续按组进行插入排序，直至增量为1</p><h4 id="4-2图片演示"><a href="#4-2图片演示" class="headerlink" title="4.2图片演示"></a>4.2图片演示</h4><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://images2015.cnblogs.com/blog/1024555/201611/1024555-20161128110416068-1421707828.png" alt="img" title="">                </div>                <div class="image-caption">img</div>            </figure><h4 id="4-3基本代码实现"><a href="#4-3基本代码实现" class="headerlink" title="4.3基本代码实现"></a>4.3基本代码实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">shellSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//设置增量gap为length/2,每次以gap=gap/2的方式缩小增量</span></span><br><span class="line">    <span class="keyword">int</span> len = arr.length, gap = len / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">while</span> (gap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//代码与直接插入排序基本一致</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = gap; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> current = arr[i], j;</span><br><span class="line">            <span class="keyword">for</span> (j = i - gap; j &gt;= <span class="number">0</span>; j -= gap) &#123;</span><br><span class="line">                <span class="keyword">if</span> (arr[j] &gt; current) &#123;</span><br><span class="line">                    arr[j + gap] = arr[j];</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            arr[j + gap] = current;</span><br><span class="line">        &#125;</span><br><span class="line">        gap /= <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-快速排序"><a href="#5-快速排序" class="headerlink" title="5.快速排序"></a>5.快速排序</h3><h4 id="5-1算法描述"><a href="#5-1算法描述" class="headerlink" title="5.1算法描述"></a>5.1算法描述</h4><p>快排采用分治思想将待排序序列分为2个子序列，具体描述如下：</p><ul><li>从序列中挑出1个元素，作为基准(pivot);</li><li>重新排序序列，将比基准值小的元素放在基准前面，比基准值大的元素放在基准后面；</li><li>递归地对小于基准值和大于基准值元素的子序列进行排序</li></ul><h4 id="5-2图片演示"><a href="#5-2图片演示" class="headerlink" title="5.2图片演示"></a>5.2图片演示</h4><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://img-blog.csdn.net/20150810110155861" alt="这里写图片描述" title="">                </div>                <div class="image-caption">这里写图片描述</div>            </figure><h4 id="5-3基本代码实现"><a href="#5-3基本代码实现" class="headerlink" title="5.3基本代码实现"></a>5.3基本代码实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (left &gt;= right) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> index = partition(arr, left, right);<span class="comment">//切分</span></span><br><span class="line">    quickSort(arr, left, index - <span class="number">1</span>);<span class="comment">//对左半部分进行排序</span></span><br><span class="line">    quickSort(arr, index + <span class="number">1</span>, right);<span class="comment">//对右半部分进行排序</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = left, j = right, pivot = arr[left];<span class="comment">//左右扫描指针和基准pivot</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">        <span class="keyword">while</span> (arr[j] &gt;= pivot &amp;&amp; i &lt; j)<span class="comment">//从右至左扫描小于基准的数</span></span><br><span class="line">            j--;</span><br><span class="line">        <span class="keyword">while</span> (arr[i] &lt;= pivot &amp;&amp; i &lt; j)<span class="comment">//从左至右扫描大于基准的数</span></span><br><span class="line">            i++;</span><br><span class="line">        <span class="comment">//将两者进行交换</span></span><br><span class="line">        <span class="keyword">int</span> temp = arr[i];</span><br><span class="line">        arr[i] = arr[j];</span><br><span class="line">        arr[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将基准放入正确位置</span></span><br><span class="line">    arr[left] = arr[i];</span><br><span class="line">    arr[i] = pivot;</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-归并排序"><a href="#6-归并排序" class="headerlink" title="6.归并排序"></a>6.归并排序</h3><h4 id="6-1算法描述"><a href="#6-1算法描述" class="headerlink" title="6.1算法描述"></a>6.1算法描述</h4><ul><li>将长度为n的输入序列分成两个长度为n/2的子序列;</li><li>对两个子序列递归进行归并排序;</li><li>将两个排序好的子序列合并成一个最终排序序列</li></ul><h4 id="6-2动画演示"><a href="#6-2动画演示" class="headerlink" title="6.2动画演示"></a>6.2动画演示</h4><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://images2017.cnblogs.com/blog/849589/201710/849589-20171015230557043-37375010.gif" alt="img" title="">                </div>                <div class="image-caption">img</div>            </figure><h4 id="6-3基本代码实现"><a href="#6-3基本代码实现" class="headerlink" title="6.3基本代码实现"></a>6.3基本代码实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] mergeSort(<span class="keyword">int</span>[] arr) &#123;</span><br><span class="line">    <span class="keyword">int</span> len = arr.length;</span><br><span class="line">    <span class="keyword">if</span> (len &lt; <span class="number">2</span>) <span class="keyword">return</span> arr;</span><br><span class="line">    <span class="keyword">int</span> mid = len / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span>[] left = Arrays.copyOfRange(arr, <span class="number">0</span>, mid);</span><br><span class="line">    <span class="keyword">int</span>[] right = Arrays.copyOfRange(arr, mid, len);</span><br><span class="line">    <span class="keyword">return</span> merge(mergeSort(left),mergeSort(right));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span>[] merge(<span class="keyword">int</span>[] left, <span class="keyword">int</span>[] right) &#123;</span><br><span class="line">    <span class="keyword">int</span>[] result = <span class="keyword">new</span> <span class="keyword">int</span>[left.length + right.length];</span><br><span class="line">    <span class="keyword">int</span> idx = <span class="number">0</span>, l = <span class="number">0</span>, r = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (l &lt;left.length &amp;&amp; r&lt;right.length) &#123;</span><br><span class="line">        <span class="keyword">if</span> (left[l] &lt; right[r]) &#123;</span><br><span class="line">            result[idx++] = left[l++];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            result[idx++] = right[r++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; left.length) &#123;</span><br><span class="line">        result[idx++] = left[l++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (r &lt; right.length) &#123;</span><br><span class="line">        result[idx++] = right[r++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7-堆排序"><a href="#7-堆排序" class="headerlink" title="7.堆排序"></a>7.堆排序</h3><p>堆排序是利用堆这种数据结构所设计的一种排序算法</p><h4 id="7-1算法描述"><a href="#7-1算法描述" class="headerlink" title="7.1算法描述"></a>7.1算法描述</h4><ul><li>将待排序序列构建成大根堆或小根堆，此堆为初始无序区</li><li>将堆顶元素R[1]与堆最后一个元素R[n]交换，得到新的无序区(R[1],R[2],…,R[n-1])和新的有序区(R[n])，且满足R[1,2,…,n-1]都小于等于或大于等于R[n]</li><li>由于交换后的堆顶R[1]可能违反堆的性质，因此将当前无序区R[1,2,…,n-1]重新调整为新堆</li><li>接着将堆顶元素R[1]与无序区最后一个元素交换，得到新的无序区(R[1],R[2],…,R[n-2])和新的有序区(R[n-1],R[n])</li><li>不断重复上述过程，直至有序区元素个数为n-1，排序完成</li></ul><h4 id="7-2动画演示"><a href="#7-2动画演示" class="headerlink" title="7.2动画演示"></a>7.2动画演示</h4><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://images2017.cnblogs.com/blog/849589/201710/849589-20171015231308699-356134237.gif" alt="img" title="">                </div>                <div class="image-caption">img</div>            </figure><h4 id="7-3基本代码实现"><a href="#7-3基本代码实现" class="headerlink" title="7.3基本代码实现"></a>7.3基本代码实现</h4><h3 id="8-计数排序"><a href="#8-计数排序" class="headerlink" title="8.计数排序"></a>8.计数排序</h3><p>计数排序不是基于比较的排序算法，其核心在于将输入的数据值转化为键存储在额外开辟的数组空间中。 作为一种线性时间复杂度的排序，<strong>计数排序要求输入的数据必须是有确定范围的整数</strong>。</p><p>计数排序是一个稳定的排序算法。当输入的元素是 n 个 0到 k 之间的整数时，<strong>时间复杂度是O(n+k)，空间复杂度也是O(n+k)</strong>，其排序速度快于任何比较排序算法。<strong>当k不是很大并且序列比较集中时，计数排序是一个很有效的排序算法。</strong></p><h4 id="8-1算法描述"><a href="#8-1算法描述" class="headerlink" title="8.1算法描述"></a>8.1算法描述</h4><p>找出待排序数组中的最大和最小元素</p><p>统计数组中的每个值为i的元素出现的次数，存入数组C的第i项</p><p>扫描数组C将数组下标i填充到新数组中，每填充一次C[i]-1，直到C[i]为0，扫描C[i+1]</p><h4 id="8-2动画演示"><a href="#8-2动画演示" class="headerlink" title="8.2动画演示"></a>8.2动画演示</h4><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://images2017.cnblogs.com/blog/849589/201710/849589-20171015231740840-6968181.gif" alt="img" title="">                </div>                <div class="image-caption">img</div>            </figure><h4 id="8-3基本代码实现"><a href="#8-3基本代码实现" class="headerlink" title="8.3基本代码实现"></a>8.3基本代码实现</h4><h3 id="9-桶排序"><a href="#9-桶排序" class="headerlink" title="9.桶排序"></a>9.桶排序</h3><p>桶排序是计数排序的升级版，设置映射函数将待排序数据分到有限数量的桶里，每个桶再分别进行排序。</p><p>桶排序最好情况下的时间复杂度为O(n)，具体情况的时间复杂度取决于各个桶之间对数据进行排序的时间复杂度。因此，桶划分的越小，各个桶之间的数据越少，排序所用时间也就越少，相应的空间消耗也会越大。</p><h4 id="9-1算法描述"><a href="#9-1算法描述" class="headerlink" title="9.1算法描述"></a>9.1算法描述</h4><p>预先定义多个定长数组作为空桶</p><p>扫描待排序序列，将数据依次放到对应的桶里</p><p>对每个非空桶进行排序</p><p>将每个非空桶排序后的数据依次拼接起来</p><h4 id="9-2图片演示"><a href="#9-2图片演示" class="headerlink" title="9.2图片演示"></a>9.2图片演示</h4><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://images2017.cnblogs.com/blog/849589/201710/849589-20171015232107090-1920702011.png" alt="img" title="">                </div>                <div class="image-caption">img</div>            </figure><h4 id="9-3基本代码实现"><a href="#9-3基本代码实现" class="headerlink" title="9.3基本代码实现"></a>9.3基本代码实现</h4><h3 id="10-基数排序"><a href="#10-基数排序" class="headerlink" title="10.基数排序"></a>10.基数排序</h3><p>基数排序是按照低位先排序，然后收集；再依次对高位进行排序，收集。</p><p>基数排序基于分别排序，分别收集，所以是稳定的。但基数排序的性能比桶排序要略差，每一次关键字的桶分配都需要O(n)的时间复杂度，而且分配之后得到新的关键字序列又需要O(n)的时间复杂度。假如待排数据可以分为d个关键字，则基数排序的时间复杂度将是O(d*2n) ，当然d要远远小于n，因此基本上还是线性级别的。</p><p>基数排序的空间复杂度为O(n+k)，其中k为桶的数量。一般来说n&gt;&gt;k，因此额外空间需要大概n个左右。</p><h4 id="10-1算法描述"><a href="#10-1算法描述" class="headerlink" title="10.1算法描述"></a>10.1算法描述</h4><p>扫描待排序序列找出最大数确定最大数位数</p><p>从最低位开始取每位组成radix数组</p><p>对radix进行计数排序</p><h4 id="10-2动画演示"><a href="#10-2动画演示" class="headerlink" title="10.2动画演示"></a>10.2动画演示</h4><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://images2017.cnblogs.com/blog/849589/201710/849589-20171015232453668-1397662527.gif" alt="img" title="">                </div>                <div class="image-caption">img</div>            </figure><h4 id="10-3基本代码实现"><a href="#10-3基本代码实现" class="headerlink" title="10.3基本代码实现"></a>10.3基本代码实现</h4><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><blockquote><ol><li><a href="https://www.cnblogs.com/onepixel/p/7674659.html" target="_blank" rel="noopener">十大经典算法</a></li></ol></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-冒泡排序&quot;&gt;&lt;a href=&quot;#1-冒泡排序&quot; class=&quot;headerlink&quot; title=&quot;1.冒泡排序&quot;&gt;&lt;/a&gt;1.冒泡排序&lt;/h3&gt;&lt;h4 id=&quot;1-1算法描述&quot;&gt;&lt;a href=&quot;#1-1算法描述&quot; class=&quot;headerlink&quot; ti
      
    
    </summary>
    
    
      <category term="数据结构与算法" scheme="https://xdmqp.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="排序算法" scheme="https://xdmqp.github.io/tags/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Kafka基础</title>
    <link href="https://xdmqp.github.io/2020/11/24/Kafka%E5%9F%BA%E7%A1%80/"/>
    <id>https://xdmqp.github.io/2020/11/24/Kafka%E5%9F%BA%E7%A1%80/</id>
    <published>2020-11-23T16:00:00.000Z</published>
    <updated>2021-07-06T08:37:26.037Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Kafka基础"><a href="#Kafka基础" class="headerlink" title="Kafka基础"></a>Kafka基础</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>Kafka 是一个<strong>分布式</strong>的基于<strong>发布/订阅模式</strong>的消息队列（Message Queue），主要应用于大数据实时处理领域。</p><h2 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h2><h3 id="传统消息队列应用场景"><a href="#传统消息队列应用场景" class="headerlink" title="传统消息队列应用场景"></a>传统消息队列应用场景</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/xdmqp/myPic/main/img/image-20201123173826318.png" alt="image-20201123173826318" title="">                </div>                <div class="image-caption">image-20201123173826318</div>            </figure><p><strong>消息队列优点：</strong></p><ol><li>解耦：允许独立扩展或修改两边的处理过程，只需确保它们遵守同样的接口约束</li><li>可恢复性：系统一部分组件失效时，不会影响整个系统。<strong>消息队列降低了进程间的耦合度，即使一个处理消息的进程挂掉，加入队列中的消息扔可以在系统恢复后被处理</strong></li><li>缓冲：有助于控制和优化数据流经过系统的速度，<strong>解决生产消息和消费消息的处理速度不一致的情况</strong></li><li>灵活性&amp;峰值处理能力：<strong>在访问量剧增的情况下</strong>，应用仍然需要继续发挥作用，但是这样的突发流量并不常见。如果为以能处理这类峰值访问为标准来投入资源随时待命无疑是巨大的浪费。<strong>使用消息队列能够使关键组件顶住突发的访问压力，而不会因为突发的超负荷的请求而完全崩溃。</strong></li><li>异步通信：很多时候，用户不想也不需要立即处理消息。消息队列提供了异步处理机制，<strong>允许用户把一个消息放入队列，但并不立即处理它</strong>。想向队列中放入多少消息就放多少，然后在需要的时候再去处理它们。</li></ol><h3 id="消息队列的两种模式"><a href="#消息队列的两种模式" class="headerlink" title="消息队列的两种模式"></a>消息队列的两种模式</h3><h4 id="点对点模式"><a href="#点对点模式" class="headerlink" title="点对点模式"></a>点对点模式</h4><p>一对一，消费者主动拉取数据，消息收到后立刻从队列中清除</p><p>消息生产者生产消息发送到Queue中，然后消息消费者从Queue中取出并且消费消息。消息被消费以后，queue 中不再有存储，所以消息消费者不可能消费到已经被消费的消息。Queue 支持存在多个消费者，但是对一个消息而言，只会有一个消费者可以消费。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/xdmqp/myPic/main/img/image-20201123174556962.png" alt="image-20201123174556962" title="">                </div>                <div class="image-caption">image-20201123174556962</div>            </figure><h4 id="发布订阅模式"><a href="#发布订阅模式" class="headerlink" title="发布订阅模式"></a>发布订阅模式</h4><p>一对多，消费者消费数据后不会清除消息</p><p>消息生产者（发布）将消息发布到 topic 中，同时有多个消息消费者（订阅）消费该消息。和点对点方式不同，发布到 topic 的消息会被所有订阅者消费。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/xdmqp/myPic/main/img/image-20201123174603211.png" alt="image-20201123174603211" title="">                </div>                <div class="image-caption">image-20201123174603211</div>            </figure><h3 id="Kafka基础架构"><a href="#Kafka基础架构" class="headerlink" title="Kafka基础架构"></a>Kafka基础架构</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/xdmqp/myPic/main/img/image-20201123174638452.png" alt="image-20201123174638452" title="">                </div>                <div class="image-caption">image-20201123174638452</div>            </figure><p><strong>Producer  ：</strong>消息生产者，就是向 kafka broker 发消息的客户端；<br><strong>Consumer</strong>  ：消息消费者，向 kafka broker 取消息的客户端；<br><strong>Consumer Group  （CG ）：</strong>消费者组，由多个 consumer 组成。 消费者组内每个消费者负责消费不同分区的数据，一个分区只能由一个 组内 消费者消费；消费者组之间互不影响。所有的消费者都属于某个消费者组，即 消费者组是逻辑上的一个订阅者。<br><strong>Broker  ：</strong>一台 kafka 服务器就是一个 broker。一个集群由多个 broker 组成。一个 broker可以容纳多个 topic。<br><strong>Topic  ：</strong>可以理解为一个队列， 生产者和消费者面向的都是一个 topic；<br><strong>Partition ：</strong>为了实现扩展性，一个非常大的 topic 可以分布到多个 broker（即服务器）上，一个 topic  可以分为多个 partition，每个 partition 是一个有序的队列；<br><strong>Replica：</strong>副本，为保证集群中的某个节点发生故障时，该节点上的 partition 数据不丢失，且 kafka 仍然能够继续工作，kafka 提供了副本机制，一个 topic 的每个分区都有若干个副本，一个 leader 和若干个 follower</p><p><strong>leader ：</strong>每个分区多个副本的“主”，生产者发送数据的对象，以及消费者消费数据的对象都是 leader。<br><strong>follower ：</strong>每个分区多个副本中的“从”，实时从 leader 中同步数据，保持和 leader 数据的同步。leader 发生故障时，某个 follower 会成为新的 follower</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Kafka基础&quot;&gt;&lt;a href=&quot;#Kafka基础&quot; class=&quot;headerlink&quot; title=&quot;Kafka基础&quot;&gt;&lt;/a&gt;Kafka基础&lt;/h1&gt;&lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概
      
    
    </summary>
    
    
      <category term="大数据" scheme="https://xdmqp.github.io/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
    
      <category term="Kafka" scheme="https://xdmqp.github.io/tags/Kafka/"/>
    
      <category term="大数据" scheme="https://xdmqp.github.io/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
  </entry>
  
  <entry>
    <title>Linux文件或目录权限</title>
    <link href="https://xdmqp.github.io/2020/11/17/Linux%E6%96%87%E4%BB%B6%E6%88%96%E7%9B%AE%E5%BD%95%E6%9D%83%E9%99%90/"/>
    <id>https://xdmqp.github.io/2020/11/17/Linux%E6%96%87%E4%BB%B6%E6%88%96%E7%9B%AE%E5%BD%95%E6%9D%83%E9%99%90/</id>
    <published>2020-11-16T16:00:00.000Z</published>
    <updated>2021-07-06T08:37:57.241Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Linux文件或目录权限"><a href="#Linux文件或目录权限" class="headerlink" title="Linux文件或目录权限"></a>Linux文件或目录权限</h1><h2 id="权限表示"><a href="#权限表示" class="headerlink" title="权限表示"></a>权限表示</h2><p>文件或目录的访问权限有<strong>只读、只写和可执行</strong>三种。以文件为例，只读权限表示只允许读其内容，而禁止对其做任何的更改操作。可执行权限表示允许将该文件作为一个程序执行。文 件被创建时，文件所有者自动拥有对该文件的读、写和可执行权限，以便于对文件的阅读和修改。用户也可根据需要把访问权限设置为需要的任何组合。</p><p>有三种不同类型的用户可对文件或目录进行访问：<strong>文件所有者，同组用户、其他用户</strong>。所有者一般是文件的创建者。所有者可以允许同组用户有权访问文件，还可以将文件的访问权限赋予系统中的其他用户。在这种情况下，系统中每一位用户都能访问该用户拥有的文件或目录。</p><p>每一文件或目录的访问权限都有<strong>三组</strong>，每组用三位表示，分别为：</p><ul><li><strong>文件属主的读、写和执行权限</strong></li><li><strong>与属主同组的用户的读、写和执行权限</strong></li><li><strong>系统中其他用户的读、写和执行权限</strong></li></ul><p>当用<code>ls -l</code>命令显示文件或目录的详细信息时，最左边的一列为文件的访问权限。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ls -l README.txt </span><br><span class="line">-rwxrw-r-- 1 root root 1366 Nov 17 14:48 README.txt</span><br></pre></td></tr></table></figure><p>其中，横线代表空许可，r代表只读，w代表写，x代表可执行。访问权限这里共有10个位置，第一个字符指定了文件类型，如果为“-”代表是文件，如果是“d“代表是一个目录。</p><p>上面的-rwxrw-r–代表README.txt<strong>是一个普通文件，其文件所有者有读、写和执行权限，与文件所有者同组用户具有读写权限，其他用户具有读权限。</strong></p><h2 id="权限修改命令"><a href="#权限修改命令" class="headerlink" title="权限修改命令"></a>权限修改命令</h2><h3 id="chmod命令"><a href="#chmod命令" class="headerlink" title="chmod命令"></a>chmod命令</h3><p>用于改变文件或目录的访问权限</p><h4 id="1-文字设定法"><a href="#1-文字设定法" class="headerlink" title="1.文字设定法"></a><strong>1.文字设定法</strong></h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod ［who］ ［+ | – | =］ ［mode］ 文件名</span><br></pre></td></tr></table></figure><p>who可以是下述字母中任一个或者它们的组合：</p><ul><li>u 表示“用户（user）”，即文件或目录的所有者。</li><li>g 表示“同组（group）用户”，即与文件属主有相同组ID的所有用户。</li><li>o 表示“其他（others）用户”。</li><li>a 表示“所有（all）用户”。它是系统默认值。</li></ul><p>操作符号可以是：</p><ul><li>+ 添加某个权限。</li><li>– 取消某个权限。</li><li>= 赋予给定权限并取消其他所有权限（如果有的话）。</li><li>设置mode所表示的权限可用下述字母的任意组合：</li><li>r 可读。</li><li>w 可写。</li><li>x 可执行。</li><li>X 只有目标文件对某些用户是可执行的或该目标文件是目录时才追加x 属性。</li><li>s 在文件执行时把进程的属主或组ID置为该文件的文件属主。方式“u＋s”设置文件的用户ID位，“g＋s”设置组ID位。</li><li>t 保存程序的文本到交换设备上。</li><li>u 与文件属主拥有一样的权限。</li><li>g 与和文件属主同组的用户拥有一样的权限。</li><li>o 与其他用户拥有一样的权限。</li><li>-c : 若该档案权限确实已经更改，才显示其更改动作</li><li>-f : 若该档案权限无法被更改也不要显示错误讯息</li><li>-v : 显示权限变更的详细资料</li><li>-R : 对目前目录下的所有档案与子目录进行相同的权限变更(即以递回的方式逐个变更)</li><li>–help : 显示辅助说明</li><li>–version : 显示版本</li></ul><p>文件名：以空格分开的要改变权限的文件列表，支持通配符。在一个命令行中可给出多个权限方式，其间用逗号隔开。</p><p>例如：chmod g+r，o+r example使同组和其他用户对文件example 有读权限。</p><h4 id="2-数字设定法"><a href="#2-数字设定法" class="headerlink" title="2.数字设定法"></a>2.数字设定法</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod ［mode］ 文件名</span><br></pre></td></tr></table></figure><p><strong>首先要了解数字所表示的权限属性的含义：0表示没有权限，1表示可执行权限，2表示可写权限，4表示可读权限，然后将其相加。因此mode由三位0到7的数字组成，分别表示文件所有者、所有者同组用户和其他用户的权限。</strong></p><p>例如 chmod 750 test.txt的含义为：文件所有者具有读、写和执行权限，所有者同组用户具有读和执行权限，其他用户没有任何权限。</p><h3 id="chgrp命令"><a href="#chgrp命令" class="headerlink" title="chgrp命令"></a>chgrp命令</h3><p>改变文件或目录所属的组</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chgrp ［option］ group filename</span><br></pre></td></tr></table></figure><p><strong>参数：</strong></p><ul><li>-c或–changes 效果类似”-v”参数，但仅回报更改的部分。</li><li>-f或–quiet或–silent 　不显示错误信息。</li><li>-h或–no-dereference 　只对符号连接的文件作修改，而不更动其他任何相关文件。</li><li>-R或–recursive 　递归处理，将指定目录下的所有文件及子目录一并处理。</li><li>-v或–verbose 　显示指令执行过程。</li><li>–help 　在线帮助。</li><li>–reference=&lt;参考文件或目录&gt; 　把指定文件或目录的所属群组全部设成和参考文件或目录的所属群组相同。</li><li>–version 　显示版本信息。</li></ul><p>该命令改变指定指定文件所属的用户组。<strong>其中group可以是用户组ID，也可以是/etc/group文件中用户组的组名</strong>。文件名是以空格分开的要改变属组的文件列表，支持通配符。<strong>如果用户不是该文件的属主或超级用户，则不能改变该文件的组。</strong></p><h3 id="chown命令"><a href="#chown命令" class="headerlink" title="chown命令"></a>chown命令</h3><p>更改某个文件或目录的属主和属组。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chown [option] user或group file</span><br></pre></td></tr></table></figure><p>命令将指定文件的拥有者改为指定的用户或组。<strong>用户可以是用户名或用户ID。组可以是组名或组ID</strong>。文件是以空格分开的要改变权限的文件列表，支持通配符。</p><p><strong>参数：</strong></p><ul><li>user : 新的档案拥有者的使用者 ID</li><li>group : 新的档案拥有者的使用者群体(group)</li><li>-c : 若该档案拥有者确实已经更改，才显示其更改动作</li><li>-f : 若该档案拥有者无法被更改也不要显示错误讯息</li><li>-h : 只对于连结(link)进行变更，而非该 link 真正指向的档案</li><li>-v : 显示拥有者变更的详细资料</li><li>-R : 对目前目录下的所有档案与子目录进行相同的拥有者变更(即以递回的方式逐个变更)</li><li>–help : 显示辅助说明</li><li>–version : 显示版本</li></ul><blockquote><p><strong><a href="https://blog.csdn.net/strivenoend/article/details/80446603" target="_blank" rel="noopener">https://blog.csdn.net/strivenoend/article/details/80446603</a></strong></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Linux文件或目录权限&quot;&gt;&lt;a href=&quot;#Linux文件或目录权限&quot; class=&quot;headerlink&quot; title=&quot;Linux文件或目录权限&quot;&gt;&lt;/a&gt;Linux文件或目录权限&lt;/h1&gt;&lt;h2 id=&quot;权限表示&quot;&gt;&lt;a href=&quot;#权限表示&quot; cla
      
    
    </summary>
    
    
      <category term="Linux" scheme="https://xdmqp.github.io/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://xdmqp.github.io/tags/Linux/"/>
    
      <category term="文件目录" scheme="https://xdmqp.github.io/tags/%E6%96%87%E4%BB%B6%E7%9B%AE%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>Flume基础</title>
    <link href="https://xdmqp.github.io/2020/11/17/Flume%E5%9F%BA%E7%A1%80/"/>
    <id>https://xdmqp.github.io/2020/11/17/Flume%E5%9F%BA%E7%A1%80/</id>
    <published>2020-11-16T16:00:00.000Z</published>
    <updated>2021-07-06T08:37:15.529Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Flume基础"><a href="#Flume基础" class="headerlink" title="Flume基础"></a>Flume基础</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><h3 id="Flume定义"><a href="#Flume定义" class="headerlink" title="Flume定义"></a>Flume定义</h3><p>Flume 是 Cloudera 提供的一个高可用的，高可靠的，分布式的海量日志采集、聚合和传输的系统。Flume 基于流式架构，灵活简单。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/xdmqp/myPic/main/img/image-20201117170702468.png" alt="image-20201117170702468" title="">                </div>                <div class="image-caption">image-20201117170702468</div>            </figure><h3 id="Flume基础架构"><a href="#Flume基础架构" class="headerlink" title="Flume基础架构"></a>Flume基础架构</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/xdmqp/myPic/main/img/image-20201117170802490.png" alt="image-20201117170802490" title="">                </div>                <div class="image-caption">image-20201117170802490</div>            </figure><p>Agent是一个JVM进程，以事件的形式将数据从源头送至目的地，由三部分组成：Source、Channel、Sink，事件Event是Flume数据传输的基本单元。Event 由 Header 和 Body 两部分组成，Header 用来存放该 event 的一些属性，为 K-V 结构，Body 用来存放该条数据，形式为字节数组。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Flume基础&quot;&gt;&lt;a href=&quot;#Flume基础&quot; class=&quot;headerlink&quot; title=&quot;Flume基础&quot;&gt;&lt;/a&gt;Flume基础&lt;/h1&gt;&lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概
      
    
    </summary>
    
    
      <category term="大数据" scheme="https://xdmqp.github.io/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
    
      <category term="大数据" scheme="https://xdmqp.github.io/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
      <category term="Flume" scheme="https://xdmqp.github.io/tags/Flume/"/>
    
  </entry>
  
  <entry>
    <title>Zookeeper基础</title>
    <link href="https://xdmqp.github.io/2020/11/16/Zookeeper%E5%9F%BA%E7%A1%80/"/>
    <id>https://xdmqp.github.io/2020/11/16/Zookeeper%E5%9F%BA%E7%A1%80/</id>
    <published>2020-11-15T16:00:00.000Z</published>
    <updated>2021-07-06T08:48:28.771Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ZooKeeper基础"><a href="#ZooKeeper基础" class="headerlink" title="ZooKeeper基础"></a>ZooKeeper基础</h1><h2 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>Zookeeper是一个开源的分布式的，为分布式应用提供协调服务的Apache项目。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/xdmqp/myPic/main/img/image-20201116160146424.png" alt="image-20201116160146424" title="">                </div>                <div class="image-caption">image-20201116160146424</div>            </figure><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/xdmqp/myPic/main/img/image-20201116160219812.png" alt="image-20201116160219812" title="">                </div>                <div class="image-caption">image-20201116160219812</div>            </figure><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><p><strong><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/xdmqp/myPic/main/img/image-20201116160256917.png" alt="image-20201116160256917" title="">                </div>                <div class="image-caption">image-20201116160256917</div>            </figure></strong></p><h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><p>统一命名服务：对应用/服务进行统一命名，便于识别<br>统一配置管理：将配置信息写入一个Znode，各个客户端注册监听这个Znode，一旦Znode数据被修改，ZooKeeper将通知各个客户端服务器<br>统一集群管理：将节点信息写入一个Znode，通过监听Znode获取节点的实时状态变化<br>服务器动态上下线：服务端启动时向ZooKeeper注册信息，客户端向ZooKeeper获取当前在线服务器列表并且注册监听。当服务器上下线时，ZooKeeper向<br>客户端发送事件通知，客户端在重新获取服务器列表并注册监听。<br>软负载均衡：通过在Zookeeper中记录每台服务器的访问次数，每次让访问次数最少的服务器去处理最新的客户端请求。</p><h2 id="ZooKeeper内部原理"><a href="#ZooKeeper内部原理" class="headerlink" title="ZooKeeper内部原理"></a>ZooKeeper内部原理</h2><h3 id="选举机制"><a href="#选举机制" class="headerlink" title="选举机制"></a>选举机制</h3><p><strong>半数机制：集群中半数以上机器存活，集群可用。因此ZooKeeper适合安装奇数台服务器</strong><br>Zookeeper虽然在配置文件中并没有指定Master和Slave。但是，Zookeeper工作时，是有一个节点为Leader，其他则为Follower，Leader是通过内部的选举机制临时产生的。<br>假设有五台服务器组成的Zookeeper集群，它们的id从1-5，同时它们都是最新启动的，也就是没有历史数据，在存放数据量这一点上，都是一样的。假设这些服务器依序启动：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/xdmqp/myPic/main/img/image-20201116154538893.png" alt="image-20201116154538893" title="">                </div>                <div class="image-caption">image-20201116154538893</div>            </figure><ol><li>服务器1启动，此时只有它一台服务器启动了，它发出去的报文没有任何响应，所以它的选举状态一直是LOOKING状态。</li><li>服务器2启动，它与最开始启动的服务器1进行通信，互相交换自己的选举结果，由于两者都没有历史数据，所以id值较大的服务器2胜出，但是由于没有达到超过半数以上的服务器都同意选举它(这个例子中的半数以上是3)，所以服务器1、2还是继续保持LOOKING状态。</li><li>服务器3启动，根据前面的理论分析，服务器3成为服务器1、2、3中的老大，而与上面不同的是，此时有三台服务器选举了它，所以它成为了这次选举的Leader。</li><li>服务器4启动，根据前面的分析，理论上服务器4应该是服务器1、2、3、4中最大的，但是由于前面已经有半数以上的服务器选举了服务器3，所以它只能接收当小弟的命了。</li><li>服务器5启动，同4一样当小弟。</li></ol><h3 id="节点类型"><a href="#节点类型" class="headerlink" title="节点类型"></a>节点类型</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/xdmqp/myPic/main/img/image-20201116155012746.png" alt="image-20201116155012746" title="">                </div>                <div class="image-caption">image-20201116155012746</div>            </figure><h3 id="Stat结构体"><a href="#Stat结构体" class="headerlink" title="Stat结构体"></a>Stat结构体</h3><ol><li><p>czxid-创建节点的事务zxid</p><p>每次修改ZooKeeper状态都会收到一个zxid形式的时间戳，也就是ZooKeeper事务ID。</p><p>事务ID是ZooKeeper中所有修改总的次序。每个修改都有唯一的zxid，如果zxid1小于zxid2，那么zxid1在zxid2之前发生。</p></li><li><p>ctime - znode被创建的毫秒数(从1970年开始)</p></li><li><p>mzxid - znode最后更新的事务zxid</p></li><li><p>mtime - znode最后修改的毫秒数(从1970年开始)</p></li><li><p>pZxid-znode最后更新的子节点zxid</p></li><li><p>cversion - znode子节点变化号，znode子节点修改次数</p></li><li><p>dataversion - znode数据变化号</p></li><li><p>aclVersion - znode访问控制列表的变化号</p></li><li><p>ephemeralOwner- 如果是临时节点，这个是znode拥有者的session id。如果不是临时节点则是0。</p></li><li><p><strong>dataLength- znode的数据长度</strong></p></li><li><p><strong>numChildren - znode子节点数量</strong></p></li></ol><h3 id="监听器原理"><a href="#监听器原理" class="headerlink" title="监听器原理"></a>监听器原理</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/xdmqp/myPic/main/img/image-20201116155707823.png" alt="image-20201116155707823" title="">                </div>                <div class="image-caption">image-20201116155707823</div>            </figure><h3 id="写数据流程"><a href="#写数据流程" class="headerlink" title="写数据流程"></a>写数据流程</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/xdmqp/myPic/main/img/image-20201116160005237.png" alt="image-20201116160005237" title="">                </div>                <div class="image-caption">image-20201116160005237</div>            </figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;ZooKeeper基础&quot;&gt;&lt;a href=&quot;#ZooKeeper基础&quot; class=&quot;headerlink&quot; title=&quot;ZooKeeper基础&quot;&gt;&lt;/a&gt;ZooKeeper基础&lt;/h1&gt;&lt;h2 id=&quot;入门&quot;&gt;&lt;a href=&quot;#入门&quot; class=&quot;head
      
    
    </summary>
    
    
      <category term="大数据" scheme="https://xdmqp.github.io/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
    
      <category term="大数据" scheme="https://xdmqp.github.io/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
      <category term="ZooKeeper" scheme="https://xdmqp.github.io/tags/ZooKeeper/"/>
    
  </entry>
  
  <entry>
    <title>信息论中的熵</title>
    <link href="https://xdmqp.github.io/2020/08/18/%E4%BF%A1%E6%81%AF%E8%AE%BA%E4%B8%AD%E7%9A%84%E7%86%B5/"/>
    <id>https://xdmqp.github.io/2020/08/18/%E4%BF%A1%E6%81%AF%E8%AE%BA%E4%B8%AD%E7%9A%84%E7%86%B5/</id>
    <published>2020-08-17T16:00:00.000Z</published>
    <updated>2020-08-18T10:19:43.334Z</updated>
    
    <content type="html"><![CDATA[<h3 id="熵"><a href="#熵" class="headerlink" title="熵"></a>熵</h3><p>用来表示事件所含信息量的大小。熵越大，所含信息量越大</p><h4 id="信息量"><a href="#信息量" class="headerlink" title="信息量"></a>信息量</h4><p>假设有随机变量$X$，其取值有$x_1,x_2,…$，</p><p>每个事件发生的概率为：$P(x_i) = P(X=x_i)$，<strong>当事件发生的概率越小时，就认为该事件的信息量就越大</strong>。</p><p>信息量的计算公式为：<br>$$<br>I(x_i) = -logP(x_i)<br>$$</p><h4 id="熵-1"><a href="#熵-1" class="headerlink" title="熵"></a>熵</h4><p>熵的具体计算方式为<strong>各类事件信息量的期望值</strong>，计算公式如下：<br>$$<br>H(X) = \sum P(x_i)I(x_i) = -\sum P(x_i)logP(x_i)<br>$$</p><h3 id="相对熵"><a href="#相对熵" class="headerlink" title="相对熵"></a>相对熵</h3><p>相对熵又称<strong>KL散度</strong>，一般用来计算<strong>两个分布间的差异</strong></p><p>离散变量A和B分布的差异计算公式为：<br>$$<br>D_{KL}(A | B)=\sum P_{A}(x_i) \log (\frac{P_{A}(x_i)}{P_{B}(x_i)})=\sum P_{A}(x_i) \log (P_{A}(x_i))-\sum P_{A}(x_{i}) \log (P_{B}(x_{i}))<br>$$<br>连续变量A和B分布的差异计算公式为：<br>$$<br>D_{K L}(A | B)=\int a(x) \log \left(\frac{a(x)}{b(x)}\right)<br>$$<br>从公式中可以看出：</p><ol><li>当$P(A)=P(B)$时，即两个变量的分布完全相同，此时KL散度为0</li><li>离散事件分布相对熵计算公式中减号前的部分恰好是A的熵的相反数</li><li>$D_{KL}(A||B) \ne D_{KL}(B||A)$</li></ol><h3 id="交叉熵"><a href="#交叉熵" class="headerlink" title="交叉熵"></a>交叉熵</h3><p>交叉熵的计算公式为：<br>$$<br>H(A, B) = -\sum P_A(x_i)logP_B(x_i)<br>$$<br>从前面相对熵的计算公式中可以看出：<br>$$<br>D_{KL}(A||B) = -H(A) + H(A, B)<br>$$<br>即相对熵=-熵+交叉熵，当熵固定的时候，用相对熵衡量两个分布的差异时，等价于用交叉熵来衡量。<strong>而交叉熵的运算更为简单，因此交叉熵更适合用来当做代价。</strong></p><blockquote><p><strong>参考资料</strong></p><p>从熵到交叉熵损失函数的理解：<a href="https://www.cnblogs.com/Elaine-DWL/p/11255522.html" target="_blank" rel="noopener">https://www.cnblogs.com/Elaine-DWL/p/11255522.html</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;熵&quot;&gt;&lt;a href=&quot;#熵&quot; class=&quot;headerlink&quot; title=&quot;熵&quot;&gt;&lt;/a&gt;熵&lt;/h3&gt;&lt;p&gt;用来表示事件所含信息量的大小。熵越大，所含信息量越大&lt;/p&gt;
&lt;h4 id=&quot;信息量&quot;&gt;&lt;a href=&quot;#信息量&quot; class=&quot;headerli
      
    
    </summary>
    
    
      <category term="机器学习" scheme="https://xdmqp.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="强化学习" scheme="https://xdmqp.github.io/tags/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>基于模型的强化学习方法</title>
    <link href="https://xdmqp.github.io/2020/08/10/%E5%9F%BA%E4%BA%8E%E6%A8%A1%E5%9E%8B%E7%9A%84%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95/"/>
    <id>https://xdmqp.github.io/2020/08/10/%E5%9F%BA%E4%BA%8E%E6%A8%A1%E5%9E%8B%E7%9A%84%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95/</id>
    <published>2020-08-09T16:00:00.000Z</published>
    <updated>2021-07-06T08:29:21.177Z</updated>
    
    <content type="html"><![CDATA[<h2 id="基于模型-Model-Based-的强化学习方法"><a href="#基于模型-Model-Based-的强化学习方法" class="headerlink" title="基于模型(Model-Based)的强化学习方法"></a>基于模型(Model-Based)的强化学习方法</h2><h3 id="方法引入"><a href="#方法引入" class="headerlink" title="方法引入"></a>方法引入</h3><p>前面所说的基于价值（Q-Learning，DQN等）和基于策略（Policy Gradient、Actor-Critic、A3C等）的强化学习方法都不是基于模型的，<strong>它们都是从与环境的交互获得的经验中学习，而基于模型的强化学习方法则是尝试从对环境建立的模型中学习</strong>，一般是有两个相互独立的模型：</p><ol><li>状态转换预测模型：输入当前状态$s$和动作$a$，预测下一个状态$s’$</li></ol><p>$$<br>S_{t+1} \sim P(S_{t+1}|S_t,A_t)<br>$$</p><ol start="2"><li>奖励预测模型：输入当前状态$s$和动作$a$，预测环境的奖励$r$</li></ol><p>$$<br>R_{t+1} \sim R(R_{t+1}|S_t,A_t)<br>$$</p><p>基于模型的强化学习的思路如下图所示：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/xdmqp/myPic/main/img/Model-Based.png" alt="Model-Based" title="">                </div>                <div class="image-caption">Model-Based</div>            </figure><h3 id="训练流程"><a href="#训练流程" class="headerlink" title="训练流程"></a>训练流程</h3><p>假设有若干组如下的训练数据：<br>$$<br>S_1,A_1,R_2,S_2,A_2,R_2,…,S_T<br>$$<br>对于每组经历，我们可以将其转化为$T-1$组训练样本：<br>$$<br>S_1,A_1 \to S_2,;S_1,A_1 \to R_2<br>$$</p><p>$$<br>S_2,A_2 \to S_3,;S_2,A_2 \to R_3<br>$$</p><p>$$<br>……<br>$$</p><p>$$<br>S_{T-1},A_{T-1} \to S_T,;S_{T-1},A_{T-1} \to R_T<br>$$</p><p>这样，左边的训练样本构成了一个分类模型训练集，输入动作和状态，输出下一个状态，右边的训练样本构成了一个回归模型训练集，输入动作和状态，输出奖励。</p><p>基于模型的强化学习方法有<strong>思路清晰、无需和环境持续交互</strong>等优点，但是<strong>在实际应用中，我们建立的模型大多不能准确描述真正的环境转化模型</strong>，这时基于模型预测的效果就不太理想了。 于是就诞生了Dyna算法框架：将Model-Based和Model-Free方法结合起来，取长补短。</p><h3 id="Dyna算法框架"><a href="#Dyna算法框架" class="headerlink" title="Dyna算法框架"></a>Dyna算法框架</h3><p>Dyna将Model-Based和Model-Free方法结合起来，既从模型中学习，也从和环境交互的经历中学习，从而更新价值函数或策略函数，Dyna的设计思路如下图所示，可以看出Dyna在Model-Based方法的基础上增加了”Direct RL”过程，也就是Model-Free方法的思路。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/xdmqp/myPic/main/img/Dyna.png" alt="Dyna算法思路" title="">                </div>                <div class="image-caption">Dyna算法思路</div>            </figure><p>Dyna算法框架和不同的Model-Free方法结合到一起，可以得到不同的算法。如果使用基于价值的Q-Learning，就得到Dyna-Q算法。</p><h3 id="Dyna-Q算法流程"><a href="#Dyna-Q算法流程" class="headerlink" title="Dyna-Q算法流程"></a>Dyna-Q算法流程</h3><p>下面给出基于价值函数的Dyna-Q算法的流程，假设模型使用的是查表法：</p><ol><li><p>初始化任意一个状态$s$，任意一个动作$a$对应的状态价值$Q(s,a)$，初始化奖励模型$R(s,a)$和状态模型$P(s,a)$</p></li><li><p>for i=1 to最大迭代次数T:</p><p>a) $S \gets current \quad state$</p><p>b) $A \gets \epsilon-greedy(S,Q)$</p><p>c) 执行动作$A$，得到新状态$S’$和奖励$R$</p><p>d) Q-Learning更新价值函数：$Q(S,A) =Q(S,A) + \alpha[R +\gamma\max_aQ(S’,a) -Q(S,A)]$</p><p>e) 使用$S,A,S’$更新模型$P(s,a)$，使用$S,A,R$更新模型$R(s,a)$</p><p>f) for j=1 to 最大次数n:</p><p>​    随机选择一个之前出现过的状态$S$，在状态$S$上出现过的动作随机选择一个动作$A$</p><p>​    基于模型$P(S,A)$得到$S’$，基于模型$R(S,A)得到$R$</p><p>​    使用Q-Learning更新价值函数：$Q(S,A) =Q(S,A) + \alpha[R +\gamma\max_aQ(S’,a) -Q(S,A)]$</p></li></ol><p>从流程中可以看出，Dyna框架在每次迭代中，会先和环境交互，并更新价值函数或策略函数，接着进行n次基于模型的预测，同样更新价值函数或策略函数，实现了上述的Dyna算法思路。</p><h3 id="Dyna-2算法框架"><a href="#Dyna-2算法框架" class="headerlink" title="Dyna-2算法框架"></a>Dyna-2算法框架</h3><p>在Dyna算法框架的基础上后来又发展出了Dyna-2算法框架。和Dyna相比，Dyna-2将和和环境交互的经历以及模型的预测这两部分使用进行了分离。还是以Q函数为例，Dyna-2将记忆分为永久性记忆（permanent memory）和瞬时记忆（transient memory）, 其中永久性记忆利用实际的经验来更新，瞬时记忆利用模型模拟经验来更新。</p><p>永久性记忆的Q函数定义为：<br>$$<br>Q(S,A) = \phi(S,A)^T\theta<br>$$<br>瞬时记忆的Q函数定义为：<br>$$<br>Q’(S,A) = \overline{\phi}(S,A)^T\overline{\theta }<br>$$<br>组合后记忆的Q函数为：<br>$$<br>\overline{Q}(S,A) = \phi(S,A)^T\theta + \overline{\phi}(S,A)^T\overline{\theta }<br>$$<br>Dyna-2的基本思想是在选择实际的执行动作前，智能体先执行一遍从当前状态开始的基于模型的模拟，该模拟将仿真完整的轨迹，以便评估当前的动作值函数。智能体会根据模拟得到的动作值函数加上实际经验得到的值函数共同选择实际要执行的动作。价值函数的更新方式类似Sarsa(λ)。算法流程如下：</p><img src="https://raw.githubusercontent.com/xdmqp/myPic/main/img/Dyna-2.png" alt="Dyna-2" /><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>基于模型的强化学习方法一般不单独使用，而是和不基于模型的强化学习结合起来，而Dyna算法框架就是常用的实现方式。对于模型部分，可以用查表和监督学习等方法，预测或者采样得到模拟的经历。对于非模型部分，使用价值函数或者策略函数近似表示。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;基于模型-Model-Based-的强化学习方法&quot;&gt;&lt;a href=&quot;#基于模型-Model-Based-的强化学习方法&quot; class=&quot;headerlink&quot; title=&quot;基于模型(Model-Based)的强化学习方法&quot;&gt;&lt;/a&gt;基于模型(Model-Bas
      
    
    </summary>
    
    
      <category term="机器学习" scheme="https://xdmqp.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="强化学习" scheme="https://xdmqp.github.io/tags/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="Model-Based RL" scheme="https://xdmqp.github.io/tags/Model-Based-RL/"/>
    
  </entry>
  
  <entry>
    <title>强化学习 Deep Deterministic Policy Gradient</title>
    <link href="https://xdmqp.github.io/2020/08/06/Deep%20Deterministic%20Policy%20Gradient/"/>
    <id>https://xdmqp.github.io/2020/08/06/Deep%20Deterministic%20Policy%20Gradient/</id>
    <published>2020-08-05T16:00:00.000Z</published>
    <updated>2021-07-06T06:47:57.473Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Deep-Deterministic-Policy-Gradient"><a href="#Deep-Deterministic-Policy-Gradient" class="headerlink" title="Deep Deterministic Policy Gradient"></a>Deep Deterministic Policy Gradient</h2><h3 id="随机策略和确定性策略"><a href="#随机策略和确定性策略" class="headerlink" title="随机策略和确定性策略"></a>随机策略和确定性策略</h3><p>先来说一下Deterministic Policy Gradient，也就是确定性策略。顾名思义，确定性策略是相对于随机性策略而言的。对于某一些动作集合来说，它可能是连续值，或者非常高维的离散值，这样的动作空间维度极大。如果采用随机策略研究所有可能动作的概率并计算各个动作的价值，需要采样的数据量较大，学习也会比较慢，这时候确定性策略就是更好的方式啦。</p><p>对于随机策略，在相同的状态下输出的动作是不唯一的，而是满足一定的概率分布；对于确定性策略，在相同状态下利用确定性梯度优化策略，其输出的动作是确定的。</p><h3 id="DPG到DDPG"><a href="#DPG到DDPG" class="headerlink" title="DPG到DDPG"></a>DPG到DDPG</h3><p>先来看下基于Q值的随机策略梯度的梯度计算公式<br>$$<br>\nabla_{\theta}J(\pi_{\theta}) = E_{s\sim\rho^{\pi}, a\sim\pi_{\theta}}[\nabla_{\theta}log \pi_{\theta}(s,a)Q_{\pi}(s,a)]<br>$$<br>其中，$\rho^{\pi}$是状态的采样空间，$\nabla_{\theta}log \pi_{\theta}(s,a)$是分值函数，可以看出随机策略梯度需要在整个动作空间$\pi_\theta$进行采样。</p><p>而DPG基于Q值的梯度计算公式为：<br>$$<br>\nabla_{\theta}J(\pi_{\theta}) = E_{s\sim\rho^{\pi}}[\nabla_{\theta} \pi_{\theta}(s)\nabla_{a}Q_{\pi}(s,a)|<em>{a=\pi</em>{\theta}(s)}]<br>$$<br>与随机策略梯度相比，少了对动作的积分，多了Q函数对动作的倒数</p><p>从DPG到DDPG得过程可以类比DQN到DDQN的过程，将网络结构分为当前网络和目标网络。因为DPG本身就有Actor网络和Critic两个网络，所以改进后就有四个网络：<strong>Actor目标网络、Actor当前网络、Critic目标网络、Critic当前网络</strong>。其中，两个Actor网络的结构相同，两个Critic网络的结构相同。</p><h3 id="DDPG原理"><a href="#DDPG原理" class="headerlink" title="DDPG原理"></a>DDPG原理</h3><p><strong>Actor当前网络</strong>：根据当前状态$S$选择当前动作$A$，获得状态$S’$和奖励$R$；负责迭代更新策略网络参数$\theta$</p><p><strong>Actor目标网络</strong>：经验回放池采样的下一状态$S’$使用贪婪法选择动作$A’$，网络参数$\theta’$定期从$\theta$复制</p><p><strong>Critic当前网络</strong>：计算当前Q值$Q(S,A,w)$；负责迭代更新价值网络参数$w$，目标Q值$y_i = R+\gamma Q’(S’,A’,w’)$</p><p><strong>Critic目标网络</strong>：基于经验回放池和Actor目标网络提供的$S’,A’$计算目标Q值中的$Q’(S’,A’,w’)$部分，网络参数$w’$定期从$w$复制</p><p>DDPG从当前网络到目标网络的复制与DDQN不一样，DDQN直接将当前Q网络的参数复制到目标Q网络，即$w’=w$。DDPG没有采用这种硬更新方式，而是<strong>采用软更新</strong>，即每次参数只更新一点点：<br>$$<br>w’ \gets \tau w+ (1-\tau)w’<br>$$</p><p>$$<br>\theta’ \gets \tau \theta+ (1-\tau)\theta’<br>$$</p><p>其中$\tau$为更新系数，一般取值较小，如0.1或者0.01</p><p>为了学习过程增加一些随机性，增加学习的覆盖面，DDPG会对选出来的动作$A$增加一定的噪声\mathcal{N}，即：<br>$$<br>A = \pi_{\theta}(S) + \mathcal{N}<br>$$<br>然后是DDPG的损失函数，首先是Critic当前网络，<strong>仍然是采用均方误差</strong>：<br>$$<br>J(w) =\frac{1}{m}\sum\limits_{j=1}^m(y_j-Q(\phi(S_j),A_j,w))^2<br>$$<br>但是<strong>由于是确定性策略，Actor当前网络的损失函数就和之前的PG，A3C不同了</strong>:<br>$$<br>\nabla_J(\theta) = \frac{1}{m}\sum\limits_{j=1}^m[\nabla_{a}Q_(s_i,a_i,w)|<em>{s=s_i,a=\pi</em>{\theta}(s)}\nabla_{\theta} \pi_{\theta(s)}|<em>{s=s_i}]<br>$$<br>因为采用确定性策略梯度，所以当对同一状态，如果输出两个不同的动作$a_1$,$a_2$，则在Critic当前网络中会得到两个Q值：$Q_1,Q_2$。这时候就比较两者，如果$Q_1&gt;Q_2$，就增加$a_1$的概率，降低$a_2$的概率，因为Actor想要得到更大的Q值。所以Actor的损失可以理解为得到的Q值越大损失越小，Q值越小损失越大，因此只要对Critic当前网络返回的Q值加个负号即可：<br>$$<br>J(\theta) =  -\frac{1}{m}\sum\limits</em>{j=1}^m Q_(s_i,a_i,w)<br>$$</p><h3 id="算法流程"><a href="#算法流程" class="headerlink" title="算法流程"></a>算法流程</h3><p>输入：<strong>Actor当前网络，Actor目标网络，Critic当前网络，Critic目标网络,参数分别为$\theta,\theta′,w,w′$,衰减因子$\gamma$, 软更新系数$\tau$,批量梯度下降的样本数$m$,目标Q网络参数更新频率$C$,最大迭代次数$T$,随机噪音函数$\mathcal{N}$</strong></p><p>输出：<strong>最优Actor当前网络参数$\theta$,Critic当前网络参数$w$</strong></p><ol><li><p>随机初始化$\theta,w,w’=w,\theta’=theta$,清空经验回放的集合D</p></li><li><p>for i form 1 to T:</p><p>1) 初始化$S$为当前状态序列的第一个状态，拿到其特征向量$\phi(S)$</p><p>2) 在Actor当前网络基于状态$S$得到动作$A =\pi_{\theta}(\phi(S)) + \mathcal{N}$</p><p>3) 执行动作A，得到新状态$S’$，奖励$R$，是否终止状态$is_end$</p><p>4) 将${\phi(S),A,R,\phi(S’),is_end}$这个五元组存入经验回放集合$D$</p><p>5) $S=S’$</p><p>6) 从经验回放集合$D$中采样$m$个样本${\phi(S_j),A_j,R_j,\phi(S’<em>j),is_end_j}, j=1,2.,,,m$，计算目标Q值$y_j$：<br>$$<br>y_j= \begin{cases} R_j&amp; {is_end_j; is ;true}\ R_j + \gamma Q’(\phi(S’_j),\pi</em>{ \theta’}(\phi(S’<em>j)),w’)&amp; {is_end_j; is ;false} \end{cases}<br>$$<br>7) 使用均方误差损失函数$\frac{1}{m}\sum\limits</em>{j=1}^m(y_j-Q(\phi(S_j),A_j,w))^2$，通过神经网络反向传播更新Critic当前网络的所有参数$w$</p><p>8) 使用$J(\theta) =  -\frac{1}{m}\sum\limits_{j=1}^m Q_(s_i,a_i,\theta)$，通过神经网路反向传播更新Actor当前网络的所有参数$\theta$</p><p>9) $if\quaadT%C==1$，更新Critic目标网络和Actor目标网络参数：<br>$$<br>w’ \gets \tau w+ (1-\tau)w’<br>$$</p></li></ol><p>$$<br>\theta’ \gets \tau \theta+ (1-\tau)\theta’<br>$$</p><p>​      10) 如果$S’$是终止状态，当前轮迭代完毕，否则转到步骤2)</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>DDPG借鉴了DDQN的思想，通过增加双网络和经验回放，以及对Actor梯度误差损失函数的改进，比较好的解决了Actor-Critic难以收敛的问题。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Deep-Deterministic-Policy-Gradient&quot;&gt;&lt;a href=&quot;#Deep-Deterministic-Policy-Gradient&quot; class=&quot;headerlink&quot; title=&quot;Deep Deterministic Polic
      
    
    </summary>
    
    
      <category term="机器学习" scheme="https://xdmqp.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="强化学习" scheme="https://xdmqp.github.io/tags/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="Policy-Based RL" scheme="https://xdmqp.github.io/tags/Policy-Based-RL/"/>
    
      <category term="Deep Deterministic Policy Gradient" scheme="https://xdmqp.github.io/tags/Deep-Deterministic-Policy-Gradient/"/>
    
  </entry>
  
  <entry>
    <title>A3C</title>
    <link href="https://xdmqp.github.io/2020/08/05/A3C/"/>
    <id>https://xdmqp.github.io/2020/08/05/A3C/</id>
    <published>2020-08-04T16:00:00.000Z</published>
    <updated>2021-07-06T03:09:27.136Z</updated>
    
    <content type="html"><![CDATA[<h2 id="A3C"><a href="#A3C" class="headerlink" title="A3C"></a>A3C</h2><h3 id="算法引入"><a href="#算法引入" class="headerlink" title="算法引入"></a>算法引入</h3><p>A3C的改进方案类似于DQN中的经验池的思想，并且克服了DQN经验池的弊端：<strong>经验池内的数据之间相关性太强，用于训练的效果可能不佳</strong>，并且实现了异步并发的学习模型。具体就是利用多线程的方法，同时在多个线程里分别和环境进行交互学习，然后把每个线程学习到的经验保存在一个公共空间里，并且定期从公共空间里取出这些线程学习到的经验，指导自身和环境之间的学习交互。</p><h3 id="算法优化"><a href="#算法优化" class="headerlink" title="算法优化"></a>算法优化</h3><p>相比Actor-Critic，A3C的优化主要有三点：<strong>异步训练框架、网络结构优化和Critic评估点的优化</strong>。</p><h4 id="异步训练框架"><a href="#异步训练框架" class="headerlink" title="异步训练框架"></a>异步训练框架</h4><p>如上图所示，Global Network就相当于公共空间，就是一个公共的神经网络模型，该模型包括Actor网络和Critic网络两部分的功能。公共模型下有n个Worker线程，每个线程里有和公共神经网络一样的网路结构，每个线程都能相互独立地和环境进行交互获得经验数据。</p><p>每个线程与环境交互一定量的数据后，就计算当前线程里神经网络损失函数的梯度，不过计算出来的梯度并<strong>不是用来更新自己线程里的神经网络，而是去更新公共神经网络</strong>。每隔一段时间，线程会将自身的神经网络参数更新为公共神经网络的参数。</p><p>因此，公共神经网络就是我们要学习的模型，线程里的网络模型主要用于和环境交互，拿到高质量的数据来帮助模型更快收敛。</p><h4 id="网络结构优化"><a href="#网络结构优化" class="headerlink" title="网络结构优化"></a>网络结构优化</h4><p>Actor-Critic中<strong>使用了两个不同的网络Actor和Critic，而A3C中又将两个网络放到了一起</strong>，即输入状态$S$，输出状态价值$V$，和策略$\pi$。</p><h4 id="Critic评估点优化"><a href="#Critic评估点优化" class="headerlink" title="Critic评估点优化"></a>Critic评估点优化</h4><p>A3C采用了优势函数$A$作为Critic评估点，优势函数$A$在时刻t不考虑参数的默认表达式为：<br>$$<br>A(S,A,t) = Q(S,A) - V(S)<br>$$<br>其中，$Q(S,A)$通过N步采样近似估计，以加速收敛：<br>$$<br>Q(S,A) = R_t +   \gamma R_{t+1} +…\gamma^{n-1} R_{t+n-1}<br>$$<br>$V(S)$的值则需要通过Critic网络学习得到</p><p>所以，A3C中的优势函数表达为：<br>$$<br>A(S,t) = R_t +  \gamma R_{t+1} +…\gamma^{n-1} R_{t+n-1} + \gamma^n V(S’) - V(S)<br>$$<br>对于Actor和Critic的损失函数部分，加入了策略$\pi$的熵项，系数为c，即策略参数的梯度更新公式变成了：<br>$$<br>\theta = \theta + \alpha \nabla_{\theta}log \pi_{\theta}(s_t,a_t)A(S,t) + c\nabla_{\theta}H(\pi(S_t, \theta))<br>$$</p><h3 id="算法流程"><a href="#算法流程" class="headerlink" title="算法流程"></a>算法流程</h3><p>以A3C中任意一个线程的算法流程为例：</p><p>输入：<strong>公共部分的A3C神经网络结构，对应参数$\theta,w$，本线程的神经网络结构，对应参数$\theta ‘, w’$，全局共享的迭代轮数T，全局最大迭代次数$T_max$，线程内单次迭代时间序列最大长度$\T_local$，状态特征维度$n$，动作集合$A$，步长$\alpha,\beta$，熵系数$c$，衰减因子$\gamma$</strong></p><p>输出：<strong>公共部分的A3C神经网络参数$\theta,w$</strong></p><ol><li><p>更新时间序列$t=1$</p></li><li><p>重置Actor和Critic的梯度更新量：$d\theta \gets 0, dw\gets 0$</p></li><li><p>将公共部分的A3C神经网络参数同步到本线程神经网络：$\theta ‘ =\theta,;; w’=w$</p></li><li><p>$t_{start} = t$，初始化状态$s_t$</p></li><li><p>基于策略$\pi(a_t|s_t;\theta)$选择动作$a_t$</p></li><li><p>执行动作$a_t$得到奖励$r_t$和新状态$s_{t+1}$</p></li><li><p>$t \gets t+1, T \gets T+1$</p></li><li><p>如果$s_t$是终止状态或者$t-t_{start} == t_{local}$，进入步骤9，否则进入步骤5</p></li><li><p>计算最后一个时间序列位置$s_t$的$Q(s,t)$：</p></li></ol><p>$$<br>Q(s,t)= \begin{cases} 0&amp; {terminal;state}\ V(s_t,w’)&amp; {none;terminal;state,bootstrapping} \end{cases}<br>$$</p><ol start="10"><li><p>$for \quad i \in (t-1,t-2,…t_{start}):$</p><p>       a) 计算每个时刻的$Q(s,i)$：$Q(s,i) = r_i + \gamma Q(s,i+1)$</p><p>       b) 累计Actor的本地梯度更新：<br>$$<br>d\theta \gets d\theta + \nabla_{\theta ‘}log \pi_{\theta’}(s_i,a_i)(Q(s,i)-V(S_i, w’)) + c\nabla_{\theta ‘}H(\pi(s_i, \theta ‘))<br>$$<br>       c) 累计Critic的本地梯度更新：<br>$$<br>dw  \gets dw + \frac{\partial (Q(s,i)-V(S_i, w’))^2}{\partial w’}<br>$$</p></li><li><p>更新全局神经网路的模型参数：</p></li></ol><p>$$<br>\theta = \theta -\alpha d\theta,;w = w -\beta dw<br>$$</p><ol start="12"><li>如果$T &gt; T_{max}$，算法结束，输出公共神经网络参数$\theta,w$，否则进入步骤3</li></ol><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>A3C算法解决了Actor-Critic难以收敛的问题，更重要的一点就是提出了一种通用的异步并发的强化学习框架，其他强化学习算法也同样适用，这是A3C最大的贡献。</p><blockquote><p>强化学习（十五）A3C：<a href="https://www.cnblogs.com/pinard/p/10334127.html" target="_blank" rel="noopener">https://www.cnblogs.com/pinard/p/10334127.html</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;A3C&quot;&gt;&lt;a href=&quot;#A3C&quot; class=&quot;headerlink&quot; title=&quot;A3C&quot;&gt;&lt;/a&gt;A3C&lt;/h2&gt;&lt;h3 id=&quot;算法引入&quot;&gt;&lt;a href=&quot;#算法引入&quot; class=&quot;headerlink&quot; title=&quot;算法引入&quot;&gt;&lt;/a&gt;算法引
      
    
    </summary>
    
    
      <category term="机器学习" scheme="https://xdmqp.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="强化学习" scheme="https://xdmqp.github.io/tags/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="A3C" scheme="https://xdmqp.github.io/tags/A3C/"/>
    
      <category term="Policy-Based RL" scheme="https://xdmqp.github.io/tags/Policy-Based-RL/"/>
    
  </entry>
  
  <entry>
    <title>Actor-Critic</title>
    <link href="https://xdmqp.github.io/2020/08/05/Actor-Critic/"/>
    <id>https://xdmqp.github.io/2020/08/05/Actor-Critic/</id>
    <published>2020-08-04T16:00:00.000Z</published>
    <updated>2021-07-06T03:09:18.865Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Actor-Critic"><a href="#Actor-Critic" class="headerlink" title="Actor-Critic"></a>Actor-Critic</h2><h3 id="算法简介"><a href="#算法简介" class="headerlink" title="算法简介"></a>算法简介</h3><p>Actor-Critic方法分为<strong>演员Actor和评价者Critic</strong>两部分：Actor使用策略梯度方法中的策略函数，负责生成动作并与环境交互，Critic使用价值函数来评估Actor的表现，并指导Actor的下一阶段工作，也就相当于替换掉了上节策略梯度方法的蒙特卡洛法。</p><p>由于Actor-Critic有两部分，因此算法中需要做两组近似：<strong>策略函数的近似和价值函数的近似</strong>，即：<br>$$<br>策略函数近似：\pi_{\theta}(s,a) = P(a|s,\theta)\approx  \pi(a|s)<br>$$<br>$$<br>状态价值函数近似：\hat{v}(s, w) \approx v_{\pi}(s)<br>$$</p><p>$$<br>动作价值函数近似：\hat{q}(s,a,w) \approx q_{\pi}(s,a)<br>$$</p><p>我们可以通过改进蒙特卡洛梯度reinforce算法实现Actor-Critic算法</p><p>先来看一下蒙特卡洛策略梯度reinforce算法中的策略参数更新公式为：<br>$$<br>\theta = \theta + \alpha \nabla_{\theta}log \pi_{\theta}(s_t,a_t)  v_t<br>$$<br><strong>其中，$\nabla_{\theta}log \pi_{\theta}(s_t,a_t)$是分值函数，无需改动，需要改动的是$v_t$部分，不再使用蒙特卡洛方法，而是参考之前DQN的做法，使用一个Q网络作为Critic，Q网络的输入可以是状态，输出是每个动作的价值或者最优动作的价值。</strong></p><p>这样Actor就可以利用$v_t$这个最优价值迭代更新策略函数的参数$\theta$，从而选择动作，并得到reward和新状态，Critic使用reward和新状态更新网络参数$w$，接着使用新的网络参数$w$计算最优价值$v_t$。</p><h3 id="Critic可选形式"><a href="#Critic可选形式" class="headerlink" title="Critic可选形式"></a>Critic可选形式</h3><p>Critic评估点的形式主要有：</p><p>状态价值：<br>$$<br>\theta = \theta + \alpha \nabla_{\theta}log \pi_{\theta}(s_t,a_t) V(s,w)<br>$$<br>动作价值：<br>$$<br>\theta = \theta + \alpha \nabla_{\theta}log \pi_{\theta}(s_t,a_t) Q(s,a,w)<br>$$<br>TD误差：<br>$$<br>\theta = \theta + \alpha \nabla_{\theta}log \pi_{\theta}(s_t,a_t)\delta(t)<br>$$<br>$$<br>\delta(t) = R_{t+1} + \gamma V(S_{t+1}) -V(S_t)\quad or \quad\delta(t) = R_{t+1} + \gamma Q(S_{t+1}，A_{t+1} ) -Q(S_t,A_t)<br>$$</p><p>Advantage函数：<br>$$<br>\theta = \theta + \alpha \nabla_{\theta}log \pi_{\theta}(s_t,a_t)A(S,A,w,\beta)<br>$$<br>$$<br>A(S,A,w,\beta) = Q(S,A, w, \alpha, \beta) - V(S,w,\alpha)<br>$$</p><p>Td(λ)误差：<br>$$<br>\theta = \theta + \alpha \nabla_{\theta}log \pi_{\theta}(s_t,a_t)\delta(t)E_(t)<br>$$<br>Critic本身的模型参数$w$，一般采用均方误差损失函数进行迭代更新，以最简单的线性Q函数：$Q(s,a ,w) = \phi(s,a)^Tw$为例，$w$的更新方式可以表示为：<br>$$<br>\delta = R_{t+1} + \gamma Q(S_{t+1}，A_{t+1} ) -Q(S_t,A_t)<br>$$</p><p>$$<br>w = w+ \beta\delta\phi(s,a)<br>$$</p><h3 id="算法流程"><a href="#算法流程" class="headerlink" title="算法流程"></a>算法流程</h3><p>Critic评估点基于TD误差，使用神经网络计算TD误差更新网络参数，Actor也使用神经网络更新网络参数</p><p>输入：<strong>迭代轮数$T$,状态特征维度$n$,动作集合$A$,步长$\alpha$,$\beta$,衰减因子$\gamma$,探索率$\epsilon$,Critic网络结构和Actor网络结构</strong><br>输出：<strong>Actor网络参数$\theta$,Critic网络参数$w$</strong></p><ol><li><p>随机初始化所有状态和动作对应的价值$Q$</p></li><li><p>for i from i to T:<br>初始化S为当前状态序列的第一个状态，拿到其特征向量$\phi(S)$<br>在Actor网络中将$\phi(S)$作为输入，输出动作A，基于动作A得到新状态$S’$，反馈$R$<br>在Critic网络中分别使用$\phi(S)， \phi(S‘’)$作为输入，得到Q值输出$V(S)， V(S’)$<br>计算TD误差$\delta = R +\gamma V(S’) -V(S)$</p><p>使用均方误差损失函数$\sum\limits(R +\gamma V(S’) -V(S,w))^2$进行Critic网络参数$w$的更新<br>更新Actor网络参数$\theta$:<br>$\theta = \theta + \alpha \nabla_{\theta}log \pi_{\theta}(S_t,A)\delta$</p></li></ol><p>Actor的分值函数$\nabla_{\theta}log \pi_{\theta}(S_t,A)$可以选择<strong>softmax或者高斯分值函数</strong></p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>基础版Actor-Critic算法思路很好，但是难以收敛，因此仍需进行改进，接下来我们将要讨论Actor-Critic的改进方法。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Actor-Critic&quot;&gt;&lt;a href=&quot;#Actor-Critic&quot; class=&quot;headerlink&quot; title=&quot;Actor-Critic&quot;&gt;&lt;/a&gt;Actor-Critic&lt;/h2&gt;&lt;h3 id=&quot;算法简介&quot;&gt;&lt;a href=&quot;#算法简介&quot; cla
      
    
    </summary>
    
    
      <category term="机器学习" scheme="https://xdmqp.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="强化学习" scheme="https://xdmqp.github.io/tags/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="Policy-Based RL" scheme="https://xdmqp.github.io/tags/Policy-Based-RL/"/>
    
      <category term="Actor-Critic" scheme="https://xdmqp.github.io/tags/Actor-Critic/"/>
    
  </entry>
  
  <entry>
    <title>策略梯度(Policy Gradient)方法</title>
    <link href="https://xdmqp.github.io/2020/08/04/%E7%AD%96%E7%95%A5%E6%A2%AF%E5%BA%A6/"/>
    <id>https://xdmqp.github.io/2020/08/04/%E7%AD%96%E7%95%A5%E6%A2%AF%E5%BA%A6/</id>
    <published>2020-08-03T16:00:00.000Z</published>
    <updated>2021-07-06T08:22:46.293Z</updated>
    
    <content type="html"><![CDATA[<h2 id="策略梯度-Policy-Gradient-方法"><a href="#策略梯度-Policy-Gradient-方法" class="headerlink" title="策略梯度(Policy Gradient)方法"></a>策略梯度(Policy Gradient)方法</h2><h3 id="Value-Based-RL的不足"><a href="#Value-Based-RL的不足" class="headerlink" title="Value-Based RL的不足"></a>Value-Based RL的不足</h3><ul><li>对连续动作的处理能力不足。DQN相关方法只能处理离散动作，无法处理连续动作，虽然也有学者提出了连续控制DQN方法—<a href="https://arxiv.org/abs/1603.00748" target="_blank" rel="noopener">NAF</a>，但是实现过程比较复杂。</li><li>对受限状态下的问题处理能力不足。在使用特征来描述状态空间中的某一个状态时，有可能因为个体观测的限制或者建模的局限，导致真实环境下本来不同的两个状态在建模后拥有的特征描述，很有可能导致Value-Based RL无法得到最优解，而Policy-Based RL则可以有效解决这个问题</li><li>无法解决随机策略问题。Value-Based RL对应的最优策略通常是确定性策略，即从众多行为价值中选择一个最大价值的行为，而有些问题的最优策略为随机策略，这种情况下就需要使用Policy-Based RL方法</li></ul><h3 id="Policy-Based-RL的引入"><a href="#Policy-Based-RL的引入" class="headerlink" title="Policy-Based RL的引入"></a>Policy-Based RL的引入</h3><p>在Value-Based RL中，采用$\hat{q}$将动作价值函数近似表示为一个包含参数$w$的函数，接受状态和动作的输入，计算得到近似的动作价值，即：<br>$$<br>\hat{q}(s,a,w) \approx q_{\pi}(s,a)<br>$$<br>在Policy-Based RL中，采用类似思路将策略近似表示为一个包含参数$\theta$的函数，即：<br>$$<br>\pi_{\theta}(s,a) = P(a|s,\theta)\approx  \pi(a|s)<br>$$<br>将策略表示为一个连续函数后，就可以用连续函数的优化方法来寻找最优策略了，最常用的方法就是<strong>梯度上升法</strong></p><h3 id="策略梯度的优化目标"><a href="#策略梯度的优化目标" class="headerlink" title="策略梯度的优化目标"></a>策略梯度的优化目标</h3><p>用梯度上升寻找最优梯度，首先要找到一个可以优化的函数目标</p><p>最简单的优化目标就是初始状态收获的期望值，即：<br>$$<br>J_1(\theta) = V_{\pi_{\theta}}(s_1) = \mathbb{E}<em>{\pi</em>{\theta}}(G_1)<br>$$<br>但有的问题是没有明确的初始状态的，那么优化目标就可以定义为平均价值，即：<br>$$<br>J_{avV}(\theta) =\sum\limits_sd_{\pi_{\theta}}(s)V_{\pi_{\theta}}(s)<br>$$<br>其中，$d_{\pi_{\theta}}(s)$是基于策略$\pi_{\theta}$生成的马尔科夫链关于状态的静态分布</p><p>或者定义为每一时间步的平均奖励，即：<br>$$<br>J_{avR}(\theta) = =\sum\limits_sd_{\pi_{\theta}}(s) \sum\limits_a \pi_{\theta}(s,a) R_s^a<br>$$<br>无论是采用$J_1,J_{avV}$还是$J_{avR}$来优化目标，最终对$\theta$求导的梯度都可以表示为：<br>$$<br>\nabla_{\theta} J(\theta) = \mathbb{E}<em>{\pi</em>{\theta}}[\nabla_{\theta}log \pi_{\theta}(s,a) Q_{\pi}(s,a)]<br>$$<br>论文:<a href="https://homes.cs.washington.edu/~todorov/courses/amath579/reading/PolicyGradient.pdf" target="_blank" rel="noopener">https://homes.cs.washington.edu/~todorov/courses/amath579/reading/PolicyGradient.pdf</a></p><p>我们也可以采用其他可能的优化目标来做梯度上升，此时梯度式子里面的$\nabla_{\theta}log \pi_{\theta}(s,a)$并不改变，变化的只是后面的$Q_{\pi}(s,a)]$部分。$\nabla_{\theta}log \pi_{\theta}(s,a)$称为分值函数(score function)</p><p>接下来就是策略函数$\pi_{\theta}(s,a)$的设计了</p><h3 id="策略函数设计"><a href="#策略函数设计" class="headerlink" title="策略函数设计"></a>策略函数设计</h3><p>最常用的策略函数就是<strong>softmax策略函数</strong>，它主要应用于离散空间中，softmax策略使用描述状态和行为的特征$\phi(s,a)$与参数的线性组合来权衡一个行为发生的几率，即：<br>$$<br>\pi_{\theta}(s,a) = \frac{e^{\phi(s,a)^T\theta}}{\sum\limits_be^{\phi(s,b)^T\theta}}<br>$$<br>求导即得对应的分值函数：<br>$$<br>\nabla_{\theta}log \pi_{\theta}(s,a) = \phi(s,a) - \mathbb{E}<em>{\pi</em>{\theta}}[\phi(s,.)]<br>$$<br>另一种策略函数是<strong>高斯策略</strong>，它主要应用于连续行为空间中，该策略对应的行为从高斯分布$\mathbb{N(\phi(s)^T\theta, \sigma^2)}$中产生，高斯策略函数求导即得对应的分值函数：<br>$$<br>\nabla_{\theta}log \pi_{\theta}(s,a) =   \frac{(a-\phi(s)^T\theta)\phi(s)}{\sigma^2}<br>$$<br>有了策略梯度和策略函数，就能得到最简单的策略梯度算法了。</p><h3 id="蒙特卡洛策略梯度reinforce算法"><a href="#蒙特卡洛策略梯度reinforce算法" class="headerlink" title="蒙特卡洛策略梯度reinforce算法"></a>蒙特卡洛策略梯度reinforce算法</h3><p>使用价值函数$v(s)$近似策略梯度中的$Q_{\pi}(s,a)$的流程如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：N个蒙特卡洛完整序列，训练步长</span><br><span class="line">输出：策略函数的参数</span><br><span class="line">1. for 每个蒙特卡洛序列：</span><br><span class="line">a. 用蒙特卡罗法计算序列每个时间位置t的状态价值vt</span><br><span class="line">b. 对序列每个时间位置t，使用梯度上升法更新策略函数的参数</span><br></pre></td></tr></table></figure><p>$$<br>\theta = \theta + \alpha \nabla_{\theta}log \pi_{\theta}(s_t,a_t)  v_t<br>$$</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2. 返回策略函数参数，这里的策略函数可以是softmax策略，高斯策略或其他策略</span><br></pre></td></tr></table></figure><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>策略梯度提供了与DQN之类的Value-Based RL方法不同的新思路，但是仍然有很多不足。由于采用蒙特卡洛法，因此<strong>需要收集到一个完整的行为序列，将梯度收集到一起再进行算法迭代，并且蒙特卡洛法使用收获的期望来计算状态价值，会导致行为有较多变异性，参数更新的方向很可能不是策略梯度的最优方向</strong>。</p><p>因此，Policy-Based RL方法仍需要改进，随之便产生了将Policy-Based和Value-Based结合的方法：Actor-Critic。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;策略梯度-Policy-Gradient-方法&quot;&gt;&lt;a href=&quot;#策略梯度-Policy-Gradient-方法&quot; class=&quot;headerlink&quot; title=&quot;策略梯度(Policy Gradient)方法&quot;&gt;&lt;/a&gt;策略梯度(Policy Gradi
      
    
    </summary>
    
    
      <category term="机器学习" scheme="https://xdmqp.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="强化学习" scheme="https://xdmqp.github.io/tags/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="Policy-Based RL" scheme="https://xdmqp.github.io/tags/Policy-Based-RL/"/>
    
      <category term="策略梯度" scheme="https://xdmqp.github.io/tags/%E7%AD%96%E7%95%A5%E6%A2%AF%E5%BA%A6/"/>
    
  </entry>
  
  <entry>
    <title>Q-Learning和Deep Q-Learning(DQN)</title>
    <link href="https://xdmqp.github.io/2020/07/23/DQN%E5%85%A5%E9%97%A8/"/>
    <id>https://xdmqp.github.io/2020/07/23/DQN%E5%85%A5%E9%97%A8/</id>
    <published>2020-07-23T07:48:38.000Z</published>
    <updated>2021-07-06T08:14:32.956Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Q-Learning"><a href="#Q-Learning" class="headerlink" title="Q-Learning"></a>Q-Learning</h2><p><strong>Q-Learning更新Q值方法：</strong></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://www.zhihu.com/equation?tex=Q%28S_%7Bt%7D%2CA_%7Bt%7D%29+%5Cleftarrow+Q%28S_%7Bt%7D%2CA_%7Bt%7D%29%2B%5Calpha%28%7BR_%7Bt%2B1%7D%2B%5Clambda+%5Cmax+_aQ%28S_%7Bt%2B1%7D%2Ca%29%7D+-+Q%28S_t%2CA_t%29%29" alt="[公式]" title="">                </div>                <div class="image-caption">[公式]</div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://pic3.zhimg.com/80/96ee91330ffbcc21b0ac399f41372e45_720w.png" alt="Q-Learning算法" title="">                </div>                <div class="image-caption">Q-Learning算法</div>            </figure><p>Exploration and Exploitation</p><p>Exploration：随机产生action</p><p>Exploitation：根据当前Q值计算最优action，这种策略π成为greedy policy贪婪策略，也就是</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://www.zhihu.com/equation?tex=%5Cpi%28S_%7Bt%2B1%7D%29+%3D+arg%5Cmax+_aQ%28S_%7Bt%2B1%7D%2Ca%29%0A" alt="[公式]" title="">                </div>                <div class="image-caption">[公式]</div>            </figure><p>将两者结合起来就是ε-greedy策略，ε是一个很小的值，作为随机选择动作的概率</p><p><strong>ε-greedy策略是一种极其简单粗暴的方法，对于一些复杂的任务采用这种方法来探索未知空间是不可取的。因此，最近有越来越多的方法来改进这种探索机制</strong></p><p>Q-Learning算法采用表格来储存Q值，但是在现实问题中存在的state太多，用表格是存放不下的，这就需要对状态的维度进行压缩，解决方法就是价值近似函数Value Function Approximation。</p><h3 id="价值近似函数-Value-Function-Approximation"><a href="#价值近似函数-Value-Function-Approximation" class="headerlink" title="价值近似函数(Value Function Approximation)"></a>价值近似函数(Value Function Approximation)</h3><p>用一个带有参数$w$函数来近似表示Q(s,a)，即<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://www.zhihu.com/equation?tex=Q%28s%2Ca%29%5Capprox+f%28s%2Ca%2Cw%29" alt="[公式]" title="">                </div>                <div class="image-caption">[公式]</div>            </figure></p><p>$f$可以是任意类型的函数</p><p>当采用了价值近似函数后，只需将state作为输入，输出的是一个包含所有动作Q值的向量<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://www.zhihu.com/equation?tex=%5BQ%28s%2Ca_1%29%2CQ%28s%2Ca_2%29%2CQ%28s%2Ca_3%29%2C...%2CQ%28s%2Ca_n%29%5D" alt="[公式]" title="">                </div>                <div class="image-caption">[公式]</div>            </figure></p><p>到这我们就看到了Q-Learning与深度学习的结合点：<strong>用深度神经网络来表示价值近似函数$f$，从而产生了Deep Q-Learning</strong>。</p><h2 id="DQN"><a href="#DQN" class="headerlink" title="DQN"></a>DQN</h2><p>神经网络需要定义一个损失函数Loss Function，也就是标签和网络输出的偏差，目标是让损失函数最小化。为此，我们需要有样本和大量的标签数据，然后通过梯度下降Gradient Descent和反向传播Back Propagation的方法实现神经网络参数的迭代更新。其中的标签数据就是Q-Learning中的目标Q值：<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://www.zhihu.com/equation?tex=R_%7Bt%2B1%7D%2B%5Clambda+%5Cmax+_aQ%28S_%7Bt%2B1%7D%2Ca%29" alt="[公式]" title="">                </div>                <div class="image-caption">[公式]</div>            </figure>，我们的目标就是<strong>让Q值趋近于目标Q值</strong>。</p><p>因此，Q-network训练的损失函数为：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://pic4.zhimg.com/80/3858f07818d129668fc83d48d855bb1f_720w.png" alt="img" title="">                </div>                <div class="image-caption">img</div>            </figure><p>其中，$s’,a’$为下一个状态和动作</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://pic2.zhimg.com/80/c24454f472843ef5caef2733d50aba00_720w.png" alt="NIPS2013 DQN" title="">                </div>                <div class="image-caption">NIPS2013 DQN</div>            </figure><p>上图便是NIPS2013版DQN的算法流程，用到了Experience Replay也就是经验回放的技巧</p><h2 id="Nature-DQN"><a href="#Nature-DQN" class="headerlink" title="Nature DQN"></a>Nature DQN</h2><p>在NIPS2013版DQN中目标Q网络随着Q网络的更新而变化，导致<strong>目标Q值和当前Q值得相关性较大</strong>，因此Nature DQN在NIPS DQN基础上增加目标Q网络用来计算目标Q值，目标Q网络的参数还是来自Q网络，只不过是采用<strong>延迟更新</strong>的方式，在经过一定步数迭代后，再将当前Q网络的参数更新到目标Q网络。Nature DQN的损失函数定义如下：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://pic4.zhimg.com/80/741e46913effd4d0821ff57b54ff5580_720w.png" alt="img" title="">                </div>                <div class="image-caption">img</div>            </figure><p>公式中计算目标Q值使用的很久之前的参数w-，而不是Q网络中的w。</p><p>Nature DQN的算法流程如下图所示：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://mofanpy.com/static/results/reinforcement-learning/4-1-1.jpg" alt="4-1-1.jpg" title="">                </div>                <div class="image-caption">4-1-1.jpg</div>            </figure><h2 id="DQN的几种改进"><a href="#DQN的几种改进" class="headerlink" title="DQN的几种改进"></a>DQN的几种改进</h2><p>Double DQN：减少因为maxQ值带来的计算偏差，也就是过估计(overestimation)问题。Nature DQN用Q网络选择动作和计算目标Q值，Double DQN用当前Q网络选择动作，用目标Q网络计算目标Q值，也就是说Double DQN改变了Nature DQN的目标Q值计算方式，两者的计算公式对比如下：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://mofanpy.com/static/results/reinforcement-learning/4-5-1.png" alt="4-5-1.png" title="">                </div>                <div class="image-caption">4-5-1.png</div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://mofanpy.com/static/results/reinforcement-learning/4-5-2.png" alt="4-5-2.png" title="">                </div>                <div class="image-caption">4-5-2.png</div>            </figure><p>Prioritized Experience Replay：对经验池中的样本赋予优先级，根据优先级来对经验池中的样本进行采样，优先级越高，采样的概率就越高。优先级采用目标Q值与当前Q值的差值来表示。如果每次采样都对样本根据优先级排序，将会大大延长算法时间，SumTree就是一种改进方法。它是一种二叉树结构，样本的优先级p存放在叶子节点中，每个分支节点都是两个叶子节点的和，所以SumTree的根节点就是所有优先级的和sum(p)。树结构如下图所示，假设优先级p为[3,10,12,4,1,2,8,2]，则sum(p)为42。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://mofanpy.com/static/results-small/reinforcement-learning/4-6-2.png" alt="SumTree结构" title="">                </div>                <div class="image-caption">SumTree结构</div>            </figure><p>抽样时，用优先级的总和sum(p)除以采样数batch size，将[0,sum]区间分割成n(n=batch size)个子区间，比如上图就可以分割为[0-7],[7-14],[14-21],[21-28],[28-35],[35-42]，然后在每个子区间里随机选取一个数，比如在[14-21]中选择了17，然后从SumTree的根节点向下开始搜索，先对比左孩子节点的值，因为17&lt;42，就从左子树接着搜索，否则从右子树搜索（减去左孩子节点值），接着17&gt;13，就将17-13=4，再将4和16的左孩12对比，因为4&lt;12，就将12作为当前区间选择的优先级p，并且取到12对应的样本。</p><p>Dueling DQN：将传统的Q网络分成两个通道，一个输出状态state的Value，一个输出动作action的Advantage，最后再合起来得到Q，如下图所示</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://img-blog.csdnimg.cn/2019051710344679.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzMxNjA4Mg==,size_16,color_FFFFFF,t_70" alt="img" title="">                </div>                <div class="image-caption">img</div>            </figure><blockquote><p>参考资料</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Q-Learning&quot;&gt;&lt;a href=&quot;#Q-Learning&quot; class=&quot;headerlink&quot; title=&quot;Q-Learning&quot;&gt;&lt;/a&gt;Q-Learning&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;Q-Learning更新Q值方法：&lt;/strong&gt;&lt;/p&gt;
      
    
    </summary>
    
    
      <category term="机器学习" scheme="https://xdmqp.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="强化学习" scheme="https://xdmqp.github.io/tags/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="Q-Learning" scheme="https://xdmqp.github.io/tags/Q-Learning/"/>
    
      <category term="DQN" scheme="https://xdmqp.github.io/tags/DQN/"/>
    
  </entry>
  
  <entry>
    <title>Hexo使用问题汇总</title>
    <link href="https://xdmqp.github.io/2020/07/21/Hexo%E4%BD%BF%E7%94%A8%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB/"/>
    <id>https://xdmqp.github.io/2020/07/21/Hexo%E4%BD%BF%E7%94%A8%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB/</id>
    <published>2020-07-21T03:32:49.000Z</published>
    <updated>2021-07-06T08:26:07.584Z</updated>
    
    <content type="html"><![CDATA[<h4 id="数学公式渲染问题"><a href="#数学公式渲染问题" class="headerlink" title="数学公式渲染问题"></a>数学公式渲染问题</h4><p>问题描述：当md文件中包含一些比较复杂的数学公式时，在使用Typora编辑时可以正常显示数学公式，但是使用hexo g命令将md文件解析成html文件时，会报如下错误：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/xdmqp/myPic/main/img/hexo_error.png" alt="hexo_error" title="">                </div>                <div class="image-caption">hexo_error</div>            </figure><p>原因：当Latex公式中出现连续两个及以上左大括号”{“时，就会报上述错误</p><p>解决方法：每当出现连续两个及以上左大括号”{“时，使用空格将其隔开，就能正常解析了</p><h4 id="行内公式"><a href="#行内公式" class="headerlink" title="行内公式"></a>行内公式</h4><p>问题描述：Typora编辑器给出的格式只有公式块，不能定义行内公式</p><p>解决方式：在需要输入行内公式的地方前后各用一个$包围起来</p><p>如$s_t$就可以像下面这样输入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$s_t$</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;数学公式渲染问题&quot;&gt;&lt;a href=&quot;#数学公式渲染问题&quot; class=&quot;headerlink&quot; title=&quot;数学公式渲染问题&quot;&gt;&lt;/a&gt;数学公式渲染问题&lt;/h4&gt;&lt;p&gt;问题描述：当md文件中包含一些比较复杂的数学公式时，在使用Typora编辑时可以正常显示数学
      
    
    </summary>
    
    
    
      <category term="Hexo渲染公式" scheme="https://xdmqp.github.io/tags/Hexo%E6%B8%B2%E6%9F%93%E5%85%AC%E5%BC%8F/"/>
    
      <category term="行内公式" scheme="https://xdmqp.github.io/tags/%E8%A1%8C%E5%86%85%E5%85%AC%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>神经网络反向传播过程</title>
    <link href="https://xdmqp.github.io/2020/07/19/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%8F%8D%E5%90%91%E4%BC%A0%E6%92%AD%E8%BF%87%E7%A8%8B/"/>
    <id>https://xdmqp.github.io/2020/07/19/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%8F%8D%E5%90%91%E4%BC%A0%E6%92%AD%E8%BF%87%E7%A8%8B/</id>
    <published>2020-07-19T02:08:25.000Z</published>
    <updated>2021-07-06T08:23:35.161Z</updated>
    
    <content type="html"><![CDATA[<h3 id=""><a href="#" class="headerlink" title=""></a><img src="https://images2015.cnblogs.com/blog/853467/201606/853467-20160630141449671-1058672778.png" alt="img" style="zoom:50%;" /></h3><p>以图中的神经网络为例，第一层为输入层，包含了两个神经元i1，i2和截距项b1，第二层是隐藏层，包含两个神经元h1,h2和截距项b2；第三层是输出层o1,o2，激活函数采用sigmoid函数。</p><p><strong>上述神经网络中的训练过程如下：</strong></p><p><strong>Step1 前向传播</strong></p><ol><li>计算神经元h1、h2的输入加权和</li></ol><p>$$<br>ne{t_{h1}} = w1\times i1 + w2\times i2 + b1<br>$$</p><p>$$<br>ne{t_{h2}} = w3 \times i1 + w4 \times i2 + b1<br>$$</p><ol start="2"><li>通过激活函数计算神经元h1、h2的输出o1、o2</li></ol><p>$$<br>Sigmoid函数：S(x)=\frac{1}{1+e^{-x}}<br>$$</p><p>$$<br>ou{t_{h1}} = \frac{1}{ {1 + {e^{ - net_{h1}}}}}<br>$$</p><p>$$<br>ou{t_{h2}} = \frac{1}{ {1 + {e^{ - net_{h2}}}}}<br>$$</p><ol start="3"><li><p>计算输出层o1、o2的输入加权和</p><p>与步骤1同理</p></li><li><p>通过激活函数计算输出层o1、o2的输出</p><p>与步骤2同理</p></li></ol><p><strong>Setp2 反向传播</strong></p><ol><li>计算均方误差，计算公式为</li></ol><p>$$<br>{E_{total}} = \sum {\frac{1}{n}} {(t\arg et - ouput)^2}<br>$$</p><ol start="2"><li><p>隐含层到输出层的权值更新</p><p>以权值w5为例，通过对误差求w5的偏导确定w5对整体误差产生了多大的影响，并应用链式法则进行化简</p></li></ol><p>$$<br>\frac{ {\partial {E_{total}}}}{ {\partial w5}} = \frac{ {\partial {E_{total}}}}{ {\partial ou{t_{o1}}}}\times\frac{ {\partial ou{t_{o1}}}}{ {\partial ne{t_{o1}}}}\times\frac{ {\partial ne{t_{o1}}}}{ {\partial w5}}<br>$$</p><p>   其中，<br>$$<br>\frac{ {\partial {E_{total}}}}{ {\partial ou{t_{o1}}}} = \frac{ {\partial (\frac{1}{2}\times[{ {(t\arg e{t_{o1}} - ou{t_{o1}})}^2} + { {(t\arg e{t_{o2}} - ou{t_{o2}})}^2}])}}{ {\partial ou{t_{o1}}}} =  - (t\arg e{t_{o1}} - ou{t_{o1}})<br>$$</p><p>$$<br>\frac{ {\partial ou{t_{o1}}}}{ {\partial ne{t_{o1}}}} = \frac{ {\partial \frac{1}{ {1 + {e^{ - ne{t_{o1}}}}}}}}{ {\partial ne{t_{o1}}}} = ou{t_{o1}}\times(1 - ou{t_{o1}})<br>$$</p><p>$$<br>\frac{ {\partial ne{t_{o1}}}}{ {\partial w5}} = \frac{ {\partial (w5 \times ou{t_{h1}} + w6 \times ou{t_{h2}} + {b_2})}}{ {\partial w5}} = ou{t_{h1}}<br>$$</p><p>   对w5的值进行更新</p><p>$$<br>w{5^+} = w5 - \eta \times \frac{ {\partial {E_{total}}}}{ {\partial w5}}<br>$$</p><p>   同理，对w6,w7,w8进行更新</p><ol start="3"><li><p>输入层到隐含层的权值更新</p><p>与步骤2同理</p></li></ol><blockquote><p>参考资料：</p><p>从此蜕变：<a href="https://www.cnblogs.com/codehome/p/9718611.html" target="_blank" rel="noopener">https://www.cnblogs.com/codehome/p/9718611.html</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;&quot;&gt;&lt;a href=&quot;#&quot; class=&quot;headerlink&quot; title=&quot;&quot;&gt;&lt;/a&gt;&lt;img src=&quot;https://images2015.cnblogs.com/blog/853467/201606/853467-20160630141449671-1
      
    
    </summary>
    
    
      <category term="机器学习" scheme="https://xdmqp.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="神经网络" scheme="https://xdmqp.github.io/tags/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/"/>
    
      <category term="反向传播" scheme="https://xdmqp.github.io/tags/%E5%8F%8D%E5%90%91%E4%BC%A0%E6%92%AD/"/>
    
  </entry>
  
  <entry>
    <title>特征归一化方法</title>
    <link href="https://xdmqp.github.io/2020/07/15/%E7%89%B9%E5%BE%81%E5%BD%92%E4%B8%80%E5%8C%96%E6%96%B9%E6%B3%95/"/>
    <id>https://xdmqp.github.io/2020/07/15/%E7%89%B9%E5%BE%81%E5%BD%92%E4%B8%80%E5%8C%96%E6%96%B9%E6%B3%95/</id>
    <published>2020-07-14T16:00:00.000Z</published>
    <updated>2021-07-06T08:23:42.441Z</updated>
    
    <content type="html"><![CDATA[<h1 id="特征归一化方法"><a href="#特征归一化方法" class="headerlink" title="特征归一化方法"></a>特征归一化方法</h1><h2 id="线性函数归一化（Min-Max-scaling），归一化公式如下："><a href="#线性函数归一化（Min-Max-scaling），归一化公式如下：" class="headerlink" title="线性函数归一化（Min-Max scaling），归一化公式如下："></a>线性函数归一化（Min-Max scaling），归一化公式如下：</h2><p>$$<br>X_{\text {norm}}=\frac{X-X_{\text {min}}}{X_{\text {max}}-X_{\text {min}}}<br>$$</p><p>X为原始数据，Xmin和Xmax分别为原始数据的最小值和最大值</p><h2 id="0均值归一化（Z-score-standardization），归一化公式如下："><a href="#0均值归一化（Z-score-standardization），归一化公式如下：" class="headerlink" title="0均值归一化（Z-score standardization），归一化公式如下："></a>0均值归一化（Z-score standardization），归一化公式如下：</h2><p>$$<br>z=\frac{x-μ}{θ}<br>$$</p><p>x为原始数据，μ和θ分别为原始数据集的均值和方差，<strong>这种方法适用近似为高斯分布的原始数据</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;特征归一化方法&quot;&gt;&lt;a href=&quot;#特征归一化方法&quot; class=&quot;headerlink&quot; title=&quot;特征归一化方法&quot;&gt;&lt;/a&gt;特征归一化方法&lt;/h1&gt;&lt;h2 id=&quot;线性函数归一化（Min-Max-scaling），归一化公式如下：&quot;&gt;&lt;a href=&quot;#
      
    
    </summary>
    
    
      <category term="机器学习" scheme="https://xdmqp.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="机器学习" scheme="https://xdmqp.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="特征归一化" scheme="https://xdmqp.github.io/tags/%E7%89%B9%E5%BE%81%E5%BD%92%E4%B8%80%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>Linux常用命令</title>
    <link href="https://xdmqp.github.io/2020/07/12/Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    <id>https://xdmqp.github.io/2020/07/12/Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</id>
    <published>2020-07-11T16:00:00.000Z</published>
    <updated>2021-07-08T11:44:34.183Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Linux常用命令"><a href="#Linux常用命令" class="headerlink" title="Linux常用命令"></a>Linux常用命令</h3><h4 id="ls命令"><a href="#ls命令" class="headerlink" title="ls命令"></a><strong>ls命令</strong></h4><p><strong>用法：ls [option]，列出当前目录下的文件</strong></p><p>  -l：列出文件详细信息</p><p>  -a :列出目录所有文件，包含以.开始的隐藏文件</p><p>  -t：以时间排序，默认最新修改的文件在上面</p><p> -r：倒序输出</p><p> -x：按列输出，横向排序</p><p> -u：按照文件上次被访问的时间排序</p><p> -S：以文件大小排序</p><p> -h：以易读大小显示</p><p> <strong>组合命令，如-lrt，代表了”-l -r -t”，按修改时间倒序列出当前目录下的文件</strong></p><h4 id="grep"><a href="#grep" class="headerlink" title="grep"></a><strong>grep</strong></h4><p><strong>用法：grep [option] pattern files，正则表达式搜索文本</strong></p><p>-r：搜索子目录</p><p>-n：显示匹配行和行号</p><p>-l：只列出匹配的文件名</p><p>-i：不区分大小写，默认区分大小写</p><p>-w：只匹配整个单词，而不是字符串的一部分</p><p>grep pattern1 | pattern2 files ：显示匹配 pattern1 或 pattern2 的行</p><p>grep pattern1 files | grep pattern2 ：显示既匹配 pattern1 又匹配 pattern2 的行</p><h4 id="vim-vi：文件编辑"><a href="#vim-vi：文件编辑" class="headerlink" title="vim/vi：文件编辑"></a><strong>vim/vi：文件编辑</strong></h4><p>vi/vim 共分为三种模式，分别是<strong>命令模式（Command mode），输入模式（Insert mode）和底线命令模式（Last line mode）</strong>， 三种模式的切换方式如下图所示</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://www.runoob.com/wp-content/uploads/2014/07/vim-vi-workmodel.png" alt="**vim/vi工作模式切换**" title="">                </div>                <div class="image-caption">**vim/vi工作模式切换**</div>            </figure><h5 id="命令模式下常用命令"><a href="#命令模式下常用命令" class="headerlink" title="命令模式下常用命令"></a>命令模式下常用命令</h5><ol><li>i:进入输入模式，从光标当前位置开始输入</li><li>a:进入输入模式，从光标所在位置的下一个位置开始输入</li><li>o：进入输入模式，插入新的一行，从行首开始输入</li><li><strong>0:移动光标到文件开头</strong></li><li><strong>G：移动光标到文件最后</strong></li><li>$：移动光标到所在行行尾</li><li>^：移动光标到所在行行首</li><li>#l：移动光标到当前行的第#个位置</li><li>x:删除光标所在位置后面的一个字符</li><li>X：删除光标所在位置前面的一个字符</li><li><strong>dd：删除光标所在行</strong></li><li>#dd：从光标所在行开始删除#行</li><li><strong>ctrl+g：列出光标所在行行号</strong></li><li><strong>#G：移动到光标只文件的第#行行首</strong></li><li>u：撤销操作</li><li>ctrl+r：恢复操作</li></ol><h5 id="底线命令模式下常用命令"><a href="#底线命令模式下常用命令" class="headerlink" title="底线命令模式下常用命令"></a>底线命令模式下常用命令</h5><ol><li><strong>set nu：显示文件行号</strong></li><li>set nonu：隐藏文件行号</li><li><strong>#：跳到文件中的第#行</strong></li><li><strong>/关键字：查找指定关键字，按n会继续往后查找</strong></li><li>w：保存文件</li><li><strong>q：退出文件编辑</strong></li><li><strong>wq：保存并退出</strong></li><li><strong>q!：放弃一切更改，强制退出</strong></li></ol><h4 id="cd命令"><a href="#cd命令" class="headerlink" title="cd命令"></a><strong>cd命令</strong></h4><p><strong>用法 cd [option] path</strong></p><p>/path:切换到根目录中的path目录下</p><p>./path：切换到当前目录的path目录下</p><p>../path:切换到上层目录的path目录下</p><p>~：切换到当前用户的自家目录下，如果为root用户，就进去root目录下</p><p>-：切换到进入当前目录的前的目录下</p><h4 id="pwd命令"><a href="#pwd命令" class="headerlink" title="pwd命令"></a>pwd命令</h4><p><strong>打印当前工作目录路径</strong></p><p>-L：打印逻辑工作目录路径</p><p>-P：打印物理工作目录路径</p><h4 id="mkdir命令"><a href="#mkdir命令" class="headerlink" title="mkdir命令"></a>mkdir命令</h4><p><strong>用法：mkdir [option] dirname，创建文件夹</strong></p><p>-m：对创建文件夹设置存取权限</p><p>-p：在指定目录下创建文件夹 </p><h4 id="rm命令"><a href="#rm命令" class="headerlink" title="rm命令"></a>rm命令</h4><p><strong>用法：rm [option] name，删除文件或者目录</strong></p><p>-i ：删除前逐一确认</p><p>-f：直接删除，无需确认</p><p>-r：删除指定目录及以下的所有文件</p><h4 id="rmdir命令"><a href="#rmdir命令" class="headerlink" title="rmdir命令"></a>rmdir命令</h4><p><strong>用法： rm [-p] name，删除空目录</strong></p><h4 id="rz命令"><a href="#rz命令" class="headerlink" title="rz命令"></a>rz命令</h4><p><strong>用法：rz [option]，使用ZMODEM协议将本地文件上传到远程Linux服务器，不能操作文件夹</strong></p><p>-+, –append:将文件内容追加到已存在的同名文件</p><p>-a,–ascii:以文本方式传输</p><p>-b, –binary:以二进制方式传输，推荐使用</p><p>–delay-startup N:等待N秒</p><p>-e, –escape:对所有控制字符转义，建议使用</p><p>-E, –rename:已存在同名文件则重命名新上传的文件，以点和数字作为后缀</p><p>-p, –protect:对ZMODEM协议有效，如果目标文件已存在则跳过 -</p><p>q, –quiet:安静执行，不输出提示信息</p><p>-v, –verbose:输出传输过程中的提示信息</p><p>-y, –overwrite:存在同名文件则替换</p><p>-X, –xmodem:使用XMODEM协议</p><p>–ymodem:使用YMODEM协议</p><p>-Z, –zmodem:使用ZMODEM协议</p><p>–version：显示版本信息</p><p>–h, –help：显示帮助信息</p><h4 id="sz命令"><a href="#sz命令" class="headerlink" title="sz命令"></a>sz命令</h4><p><strong>用法：sz [option] [filelist]，使用ZMODEM协议将多个文件从远程服务器下载到本地，不能操作文件夹</strong></p><p><strong>示例：sz file1 file2 file3</strong></p><p>选项和rz相同</p><h4 id="压缩命令"><a href="#压缩命令" class="headerlink" title="压缩命令"></a>压缩命令</h4><blockquote><p><a href="https://www.cnblogs.com/dch0/p/11111626.html" target="_blank" rel="noopener">https://www.cnblogs.com/dch0/p/11111626.html</a></p></blockquote><h4 id="mv命令"><a href="#mv命令" class="headerlink" title="mv命令"></a>mv命令</h4><p><strong>用法：mv [option]</strong></p><table><thead><tr><th>命令</th><th>操作</th></tr></thead><tbody><tr><td>mv 文件名 文件名</td><td>将源文件名改为目标文件名</td></tr><tr><td>mv 文件名 目录名</td><td>将文件移动到目标目录</td></tr><tr><td>mv 目录名 目录名</td><td>目标目录已存在，将源目录移动到目标目录；目标目录不存在则改名</td></tr></tbody></table><p>-i: 若指定目录已有同名文件，则先询问是否覆盖旧文件</p><p>-f: 在 mv 操作要覆盖某已有的目标文件时不给任何指示</p><h4 id="sed命令"><a href="#sed命令" class="headerlink" title="sed命令"></a>sed命令</h4><p><strong>按照脚本的指令处理、编辑文本文件</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed [-hnV][-e&lt;script&gt;][-f&lt;script文件&gt;][文本文件]</span><br></pre></td></tr></table></figure><p>参数说明：</p><p>-e<script>或--expression=<script> 以选项中指定的script来处理输入的文本文件。</p><p>-f<script文件>或--file=<script文件> 以选项中指定的script文件来处理输入的文本文件。</p><p>脚本说明：</p><ul><li>a ：新增， a 的后面可以接字串，而这些字串会在新的一行出现(目前的下一行)～</li><li>c ：取代， c 的后面可以接字串，这些字串可以取代 n1,n2 之间的行！</li><li>d ：删除，因为是删除啊，所以 d 后面通常不接任何咚咚；</li><li>i ：插入， i 的后面可以接字串，而这些字串会在新的一行出现(目前的上一行)；</li><li>p ：打印，亦即将某个选择的数据印出。通常 p 会与参数 sed -n 一起运行～</li><li>s ：取代，可以直接进行取代的工作，通常这个 s 的动作可以搭配正规表示法！例如 1,20s/old/new/g 就是啦！</li></ul><h4 id="find命令"><a href="#find命令" class="headerlink" title="find命令"></a>find命令</h4><p><strong>用来在指定目录下查找文件</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find path -option [-print] [-exec -ok command] &#123;&#125; \;</span><br></pre></td></tr></table></figure><p><strong>常用实例：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find. 列出当前目录及子目录下所有文件和文件夹</span><br></pre></td></tr></table></figure><p><strong>按照文件名查找：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find /home  -name "*.t?t"   *表示通配任意个字符  ?表示通配单个字符</span><br></pre></td></tr></table></figure><p><strong>按照文件时间戳查找：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">find /usr -mtime  -4   查找文件更新日时在距现在时刻4天以内的文件</span><br><span class="line">find /usr -mtime  +4   查找文件更新日时在距现在时刻5天以上的文件</span><br><span class="line">find /usr -mtime   4   查找文件更新日时在距现在时刻4天以上5天以内的文件</span><br></pre></td></tr></table></figure><p><strong>按照文件所有者和群组查找：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find / -user 用户名</span><br></pre></td></tr></table></figure><p><strong>按照文件类型查找文件：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find / -type p 列出所有管道类型文件</span><br></pre></td></tr></table></figure><p><strong>按照文件大小查找文件：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find / -size  +10M 列出大于10M的文件</span><br></pre></td></tr></table></figure><p><strong>按照文件权限查找文件：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find /var -perm 777 列出var目录下文件权限为777的文件</span><br></pre></td></tr></table></figure><h4 id="awk命令"><a href="#awk命令" class="headerlink" title="awk命令"></a>awk命令</h4><p>awk是一个强大的文本分析工具，相对于grep的查找，sed的编辑，awk在其对数据分析并生成报告时，显得尤为强大。简单来说awk就是把文件逐行的读入，以空格为默认分隔符将每行切片，切开的部分再进行各种分析处理。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk '&#123;pattern + action&#125;' &#123;filenames&#125;</span><br></pre></td></tr></table></figure><p><strong>三种调用方式：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">1.命令行方式</span><br><span class="line">awk [-F  field-separator]  'commands'  input-file(s)</span><br><span class="line">其中，commands 是真正awk命令，[-F域分隔符]是可选的。 input-file(s) 是待处理的文件。</span><br><span class="line">在awk中，文件的每一行中，由域分隔符分开的每一项称为一个域。通常，在不指名-F域分隔符的情况下，默认的域分隔符是空格。</span><br><span class="line"></span><br><span class="line">2.shell脚本方式</span><br><span class="line">将所有的awk命令插入一个文件，并使awk程序可执行，然后awk命令解释器作为脚本的首行，一遍通过键入脚本名称来调用。</span><br><span class="line">相当于shell脚本首行的：#!/bin/sh</span><br><span class="line">可以换成：#!/bin/awk</span><br><span class="line"></span><br><span class="line">3.将所有的awk命令插入一个单独文件，然后调用：</span><br><span class="line">awk -f awk-script-file input-file(s)</span><br><span class="line">其中，-f选项加载awk-script-file中的awk脚本，input-file(s)跟上面的是一样的。</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Linux常用命令&quot;&gt;&lt;a href=&quot;#Linux常用命令&quot; class=&quot;headerlink&quot; title=&quot;Linux常用命令&quot;&gt;&lt;/a&gt;Linux常用命令&lt;/h3&gt;&lt;h4 id=&quot;ls命令&quot;&gt;&lt;a href=&quot;#ls命令&quot; class=&quot;headerli
      
    
    </summary>
    
    
      <category term="Linux" scheme="https://xdmqp.github.io/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://xdmqp.github.io/tags/Linux/"/>
    
      <category term="Linux命令" scheme="https://xdmqp.github.io/tags/Linux%E5%91%BD%E4%BB%A4/"/>
    
  </entry>
  
  <entry>
    <title>概念和方法</title>
    <link href="https://xdmqp.github.io/2020/07/08/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%E6%A6%82%E5%BF%B5%E5%92%8C%E6%96%B9%E6%B3%95/"/>
    <id>https://xdmqp.github.io/2020/07/08/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%E6%A6%82%E5%BF%B5%E5%92%8C%E6%96%B9%E6%B3%95/</id>
    <published>2020-07-08T00:37:18.000Z</published>
    <updated>2021-07-06T03:19:33.627Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概念和方法"><a href="#概念和方法" class="headerlink" title="概念和方法"></a>概念和方法</h2><h3 id="1-概念"><a href="#1-概念" class="headerlink" title="1. 概念"></a>1. 概念</h3><p>强化学习是机器学习中的一类，类似于无监督学习，强化学习是在没有样本的情况下，通过个体不断与环境(environment)进行交互，从环境的反馈(reward)中不断积累经验从而获取最佳策略(policy)，在环境中达到自身的目的，这是一种试错性的学习，强化学习的基本模型如下图所示：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/rl.png" alt="强化学习基本模型" title="">                </div>                <div class="image-caption">强化学习基本模型</div>            </figure><p><strong>强化学习要素：</strong></p><p>环境状态$state$，$S_t$代表t时刻环境所处的状态</p><p>个体动作$action$，$A_t$代表t时刻个体采取的动作</p><p>环境奖励$reward$，$R_t$代表t-1时刻(上一时刻)个体采取动作$A_{t - 1}$得到的奖励</p><p>个体策略π:个体选择action的依据</p><p>价值函数$v_π(s)$：个体在策略π指导下选择action后的价值，价值函数的表达式如下：<br>$$<br>{v_\pi }(s) = { {\rm{E}}<em>\pi }({R</em>{t + 1}} + \gamma {R_{t + 2}} + {\gamma ^2}{R_{t + 3}} +  \cdots |{S_t} = s)<br>$$<br>奖励衰减因子γ：γ是一个位于[0,1]之间的值，当γ为0时代表价值函数只由当前state产生的reward决定，当γ为1时代表当前state产生的reward和后续state产生的reward对价值函数的影响是等价的</p><p>环境状态转化模型$P_{ss’}^a$：代表在状态s下采取动作a转到状态s’的概率</p><p>贪婪策略$\epsilon$：$\epsilon$也是一个位于[0,1]之间的值，代表了在当前状态下随机选择动作的概率，当$\epsilon$为0时代表在当前状态下只会选择价值函数最高的动作，不会随机选择动作</p><h3 id="2-强化学习方法分类"><a href="#2-强化学习方法分类" class="headerlink" title="2. 强化学习方法分类"></a>2. 强化学习方法分类</h3><ul><li>根据是否需要理解所处的环境可以将方法分为：<strong>Model-Free RL（Q Learning、Sarsa、Policy Gradients等）和Model-Based RL</strong>。Model-Based RL在Model-Free基础上增加了环境建模，并且能够通过想象来判断接下来的所有情况，选择其中最好的一种情况，并依据这种情况才去下一步策略</li><li>根据选择动作时的参考依据可以将方法分为：<strong>基于概率方法（Policy Gradients等）和基于价值方法（Q Learning、Sarsa等）</strong>。基于概率方法是通过分析所处的环境，直接输出下一步要采用的各种动作的概率，然后根据概率采用某一个动作，即每个动作都可能被选中，只是概率不同。基于价值方法是直接输出所有动作的价值，然后根据最高价值来选择动作。<strong>通过结合两种方法的优势，产生一种新方法：Actor-Critic，actor基于概率做出动作，critic对做出的动作给出动作价值。</strong></li><li>根据更新方式可以将方法分为：<strong>回合更新方法（Mote-carlo learning、基础 Policy Gradients等）和单步更新方法（Q Learning、Sarsa和升级Policy Gradients）</strong>。回合更新方法是在执行完一个行为序列后，将梯度收集到一起，再进行更新。单步更新方法是指每一次和环境交互后，立即更新参数。</li><li>根据交互过程中数据的使用方式可以将方法分为：<strong>在线学习方法（Sarsa、Sarsa Lambda）和离线学习方法（Q Learning）</strong>。在线学习方法是指在完成一次交互后，立即用本次交互得到的经验更新行为准则。离线学习方法是先将n次交互的经验存储起来，而后再从存储的经验中更新行为准则。</li></ul><blockquote><p>参考资料：</p><p>强化学习（一）模型基础：<a href="https://www.cnblogs.com/pinard/p/9385570.html" target="_blank" rel="noopener">https://www.cnblogs.com/pinard/p/9385570.html</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;概念和方法&quot;&gt;&lt;a href=&quot;#概念和方法&quot; class=&quot;headerlink&quot; title=&quot;概念和方法&quot;&gt;&lt;/a&gt;概念和方法&lt;/h2&gt;&lt;h3 id=&quot;1-概念&quot;&gt;&lt;a href=&quot;#1-概念&quot; class=&quot;headerlink&quot; title=&quot;1. 概念
      
    
    </summary>
    
    
      <category term="机器学习" scheme="https://xdmqp.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="强化学习" scheme="https://xdmqp.github.io/tags/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="概念" scheme="https://xdmqp.github.io/tags/%E6%A6%82%E5%BF%B5/"/>
    
      <category term="方法" scheme="https://xdmqp.github.io/tags/%E6%96%B9%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Markdown基本语法</title>
    <link href="https://xdmqp.github.io/2020/07/07/Markdown%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/"/>
    <id>https://xdmqp.github.io/2020/07/07/Markdown%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/</id>
    <published>2020-07-06T16:00:00.000Z</published>
    <updated>2021-07-09T09:16:19.359Z</updated>
    
    <content type="html"><![CDATA[<h1 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h1><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 一级标题</span><br><span class="line">## 二级标题</span><br><span class="line">### 三级标题</span><br><span class="line">#### 四级标题</span><br><span class="line">##### 五级标题</span><br><span class="line">###### 六级标题</span><br></pre></td></tr></table></figure><p>效果如下：</p><h1 id="一级标题"><a href="#一级标题" class="headerlink" title="一级标题"></a>一级标题</h1><h2 id="二级标题"><a href="#二级标题" class="headerlink" title="二级标题"></a>二级标题</h2><h3 id="三级标题"><a href="#三级标题" class="headerlink" title="三级标题"></a>三级标题</h3><h4 id="四级标题"><a href="#四级标题" class="headerlink" title="四级标题"></a>四级标题</h4><h5 id="五级标题"><a href="#五级标题" class="headerlink" title="五级标题"></a>五级标题</h5><h6 id="六级标题"><a href="#六级标题" class="headerlink" title="六级标题"></a>六级标题</h6><hr><h1 id="字体"><a href="#字体" class="headerlink" title="字体"></a>字体</h1><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">**加粗**</span><br><span class="line">*斜体*</span><br><span class="line">***斜体加粗***</span><br><span class="line">&lt;u&gt;下划线&lt;&#x2F;u&gt;</span><br><span class="line">~~删除线~~</span><br></pre></td></tr></table></figure><p>效果如下：<br><strong>加粗</strong><br><em>斜体</em><br><strong><em>斜体加粗</em></strong><br><u>下划线</u><br><del>删除线</del>  </p><hr><h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;这就是引用内容</span><br></pre></td></tr></table></figure><p>效果如下:</p><blockquote><p>这就是引用内容</p></blockquote><hr><h1 id="分割线"><a href="#分割线" class="headerlink" title="分割线"></a>分割线</h1><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">****</span><br><span class="line">上面是分割线</span><br></pre></td></tr></table></figure><p>效果如下:  </p><hr><p>上面是分割线</p><hr><h1 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h1><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">* 符号列表1</span><br><span class="line">* 符号列表2</span><br><span class="line">* 符号列表3</span><br><span class="line"></span><br><span class="line">1. 数字列表1</span><br><span class="line">2. 数字列表2</span><br><span class="line">3. 数字列表3</span><br></pre></td></tr></table></figure><p>效果如下:</p><ul><li>符号列表1</li><li>符号列表2</li><li>符号列表3</li></ul><ol><li>数字列表1  </li><li>数字列表2  </li><li>数字列表3  </li></ol><hr><h1 id="超链接"><a href="#超链接" class="headerlink" title="超链接"></a>超链接</h1><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[我的博客](https:&#x2F;&#x2F;xdmqp.github.io)</span><br></pre></td></tr></table></figure><p>效果如下：<br><a href="https://xdmqp.github.io">我的博客</a></p><hr><h1 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h1><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">![image](&#x2F;img&#x2F;avatar.jpg)</span><br></pre></td></tr></table></figure><p>效果如下:</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/avatar.jpg" alt="image" title="">                </div>                <div class="image-caption">image</div>            </figure><hr><h1 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h1><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">| 姓名 | 性别 | 年龄 |</span><br><span class="line">|  --- |:--:|:--:|</span><br><span class="line">| 李明 | 男 | 23 |</span><br><span class="line">| 李华 | 男 | 20 |</span><br></pre></td></tr></table></figure><p>效果如下：</p><table><thead><tr><th>姓名</th><th align="center">性别</th><th align="center">年龄</th></tr></thead><tbody><tr><td>李明</td><td align="center">男</td><td align="center">23</td></tr><tr><td>李华</td><td align="center">男</td><td align="center">20</td></tr></tbody></table><p><strong>PS：表格与前文要空两行才能正常显示</strong></p><hr><h1 id="公式"><a href="#公式" class="headerlink" title="公式"></a>公式</h1><p>示例:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$$</span><br><span class="line">x&#x3D;a+b</span><br><span class="line">$$</span><br></pre></td></tr></table></figure><p>效果如下：</p><p>$$<br>x=a+b<br>$$</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;标题&quot;&gt;&lt;a href=&quot;#标题&quot; class=&quot;headerlink&quot; title=&quot;标题&quot;&gt;&lt;/a&gt;标题&lt;/h1&gt;&lt;p&gt;示例：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;
      
    
    </summary>
    
    
      <category term="Markdown" scheme="https://xdmqp.github.io/categories/Markdown/"/>
    
    
      <category term="Markdown" scheme="https://xdmqp.github.io/tags/Markdown/"/>
    
  </entry>
  
</feed>
